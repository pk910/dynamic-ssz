// Code generated by dynamic-ssz. DO NOT EDIT.
package main

import (
	"github.com/attestantio/go-eth2-client/spec/altair"
	"github.com/attestantio/go-eth2-client/spec/bellatrix"
	"github.com/attestantio/go-eth2-client/spec/capella"
	"github.com/attestantio/go-eth2-client/spec/deneb"
	"github.com/attestantio/go-eth2-client/spec/phase0"
	"github.com/holiman/uint256"
	dynssz "github.com/pk910/dynamic-ssz"
	"github.com/pk910/dynamic-ssz/sszutils"
	go_bitfield "github.com/prysmaticlabs/go-bitfield"
)
var _ = sszutils.ErrListTooBig


func (t *TestBeaconBlock) MarshalSSZDyn(ds *dynssz.DynSsz, buf []byte) (dst []byte, err error) {
  dst = buf
  fn1 := func(t phase0.Slot) (err error) { // phase0.Slot
    dst = sszutils.MarshalUint64(dst, uint64(t))
    return err
  }
  fn2 := func(t phase0.ValidatorIndex) (err error) { // phase0.ValidatorIndex
    dst = sszutils.MarshalUint64(dst, uint64(t))
    return err
  }
  fn3 := func(t phase0.Root) (err error) { // phase0.Root:32
    dst = append(dst, t[:32]...)
    return err
  }
  fn4 := func(t phase0.BLSSignature) (err error) { // phase0.BLSSignature:96
    dst = append(dst, t[:96]...)
    return err
  }
  fn5 := func(t uint64) (err error) { // uint64
    dst = sszutils.MarshalUint64(dst, uint64(t))
    return err
  }
  fn6 := func(t []byte) (err error) { // []byte:32
    limit := 32
    vlen := len(t)
    if vlen > int(limit) {
      return sszutils.ErrListTooBig
    }
    vlimit := int(limit)
    if vlimit > vlen {
      vlimit = vlen
    }
    dst = append(dst, t[:vlimit]...)
    if vlen < int(limit) {
      dst = sszutils.AppendZeroPadding(dst, int(limit) - vlen)
    }
    return err
  }
  fn7 := func(t *phase0.ETH1Data) (err error) { // *phase0.ETH1Data
    // Field #0 'DepositRoot'
    if err = fn3(t.DepositRoot); err != nil {
      return err
    }
    // Field #1 'DepositCount'
    if err = fn5(t.DepositCount); err != nil {
      return err
    }
    // Field #2 'BlockHash'
    if err = fn6(t.BlockHash); err != nil {
      return err
    }
    return err
  }
  fn8 := func(t [32]byte) (err error) { // [32]byte:32
    dst = append(dst, t[:32]...)
    return err
  }
  fn9 := func(t *phase0.BeaconBlockHeader) (err error) { // *phase0.BeaconBlockHeader
    // Field #0 'Slot'
    if err = fn1(t.Slot); err != nil {
      return err
    }
    // Field #1 'ProposerIndex'
    if err = fn2(t.ProposerIndex); err != nil {
      return err
    }
    // Field #2 'ParentRoot'
    if err = fn3(t.ParentRoot); err != nil {
      return err
    }
    // Field #3 'StateRoot'
    if err = fn3(t.StateRoot); err != nil {
      return err
    }
    // Field #4 'BodyRoot'
    if err = fn3(t.BodyRoot); err != nil {
      return err
    }
    return err
  }
  fn10 := func(t *phase0.SignedBeaconBlockHeader) (err error) { // *phase0.SignedBeaconBlockHeader
    // Field #0 'Message'
    if err = fn9(t.Message); err != nil {
      return err
    }
    // Field #1 'Signature'
    if err = fn4(t.Signature); err != nil {
      return err
    }
    return err
  }
  fn11 := func(t *phase0.ProposerSlashing) (err error) { // *phase0.ProposerSlashing
    // Field #0 'SignedHeader1'
    if err = fn10(t.SignedHeader1); err != nil {
      return err
    }
    // Field #1 'SignedHeader2'
    if err = fn10(t.SignedHeader2); err != nil {
      return err
    }
    return err
  }
  fn12 := func(t []*phase0.ProposerSlashing) (err error) { // []*phase0.ProposerSlashing
    vlen := len(t)
    for i := 0; i < vlen; i++ {
      if err = fn11(t[i]); err != nil {
        return err
      }
    }
    return err
  }
  fn13 := func(t []uint64) (err error) { // []uint64
    vlen := len(t)
    for i := 0; i < vlen; i++ {
      if err = fn5(t[i]); err != nil {
        return err
      }
    }
    return err
  }
  fn14 := func(t phase0.CommitteeIndex) (err error) { // phase0.CommitteeIndex
    dst = sszutils.MarshalUint64(dst, uint64(t))
    return err
  }
  fn15 := func(t phase0.Epoch) (err error) { // phase0.Epoch
    dst = sszutils.MarshalUint64(dst, uint64(t))
    return err
  }
  fn16 := func(t *phase0.Checkpoint) (err error) { // *phase0.Checkpoint
    // Field #0 'Epoch'
    if err = fn15(t.Epoch); err != nil {
      return err
    }
    // Field #1 'Root'
    if err = fn3(t.Root); err != nil {
      return err
    }
    return err
  }
  fn17 := func(t *phase0.AttestationData) (err error) { // *phase0.AttestationData
    // Field #0 'Slot'
    if err = fn1(t.Slot); err != nil {
      return err
    }
    // Field #1 'Index'
    if err = fn14(t.Index); err != nil {
      return err
    }
    // Field #2 'BeaconBlockRoot'
    if err = fn3(t.BeaconBlockRoot); err != nil {
      return err
    }
    // Field #3 'Source'
    if err = fn16(t.Source); err != nil {
      return err
    }
    // Field #4 'Target'
    if err = fn16(t.Target); err != nil {
      return err
    }
    return err
  }
  fn18 := func(t *phase0.IndexedAttestation) (err error) { // *phase0.IndexedAttestation
    dstlen := len(dst)
    // Offset #0 'AttestingIndices'
    offset0 := len(dst)
    dst = sszutils.MarshalOffset(dst, 0)
    // Field #1 'Data'
    if err = fn17(t.Data); err != nil {
      return err
    }
    // Field #2 'Signature'
    if err = fn4(t.Signature); err != nil {
      return err
    }
    // Dynamic Field #0 'AttestingIndices'
    sszutils.UpdateOffset(dst[offset0:offset0+4], len(dst)-dstlen)
    if err = fn13(t.AttestingIndices); err != nil {
      return err
    }
    return err
  }
  fn19 := func(t *phase0.AttesterSlashing) (err error) { // *phase0.AttesterSlashing
    dstlen := len(dst)
    // Offset #0 'Attestation1'
    offset0 := len(dst)
    dst = sszutils.MarshalOffset(dst, 0)
    // Offset #1 'Attestation2'
    offset1 := len(dst)
    dst = sszutils.MarshalOffset(dst, 0)
    // Dynamic Field #0 'Attestation1'
    sszutils.UpdateOffset(dst[offset0:offset0+4], len(dst)-dstlen)
    if err = fn18(t.Attestation1); err != nil {
      return err
    }
    // Dynamic Field #1 'Attestation2'
    sszutils.UpdateOffset(dst[offset1:offset1+4], len(dst)-dstlen)
    if err = fn18(t.Attestation2); err != nil {
      return err
    }
    return err
  }
  fn20 := func(t []*phase0.AttesterSlashing) (err error) { // []*phase0.AttesterSlashing
    vlen := len(t)
    dstlen := len(dst)
    dst = sszutils.AppendZeroPadding(dst, vlen * 4)
    for i := 0; i < vlen; i++ {
      sszutils.UpdateOffset(dst[dstlen+(i*4):dstlen+((i+1)*4)], len(dst)-dstlen)
      if err = fn19(t[i]); err != nil {
        return err
      }
    }
    return err
  }
  fn21 := func(t go_bitfield.Bitlist) (err error) { // go_bitfield.Bitlist
    dst = append(dst, t[:]...)
    return err
  }
  fn22 := func(t *phase0.Attestation) (err error) { // *phase0.Attestation
    dstlen := len(dst)
    // Offset #0 'AggregationBits'
    offset0 := len(dst)
    dst = sszutils.MarshalOffset(dst, 0)
    // Field #1 'Data'
    if err = fn17(t.Data); err != nil {
      return err
    }
    // Field #2 'Signature'
    if err = fn4(t.Signature); err != nil {
      return err
    }
    // Dynamic Field #0 'AggregationBits'
    sszutils.UpdateOffset(dst[offset0:offset0+4], len(dst)-dstlen)
    if err = fn21(t.AggregationBits); err != nil {
      return err
    }
    return err
  }
  fn23 := func(t []*phase0.Attestation) (err error) { // []*phase0.Attestation
    vlen := len(t)
    dstlen := len(dst)
    dst = sszutils.AppendZeroPadding(dst, vlen * 4)
    for i := 0; i < vlen; i++ {
      sszutils.UpdateOffset(dst[dstlen+(i*4):dstlen+((i+1)*4)], len(dst)-dstlen)
      if err = fn22(t[i]); err != nil {
        return err
      }
    }
    return err
  }
  fn24 := func(t [][]byte) (err error) { // [][]byte:33:DEPOSIT_CONTRACT_TREE_DEPTH+1:32
    hasLimit, limit, err := ds.ResolveSpecValue("DEPOSIT_CONTRACT_TREE_DEPTH+1")
    if err != nil {
      return err
    }
    if !hasLimit {
      limit = 33
    }
    vlen := len(t)
    if vlen > int(limit) {
      return sszutils.ErrListTooBig
    }
    for i := 0; i < vlen; i++ {
      if err = fn6(t[i]); err != nil {
        return err
      }
    }
    if vlen < int(limit) {
      dst = sszutils.AppendZeroPadding(dst, (int(limit) - vlen) * 32)
    }
    return err
  }
  fn25 := func(t phase0.BLSPubKey) (err error) { // phase0.BLSPubKey:48
    dst = append(dst, t[:48]...)
    return err
  }
  fn26 := func(t phase0.Gwei) (err error) { // phase0.Gwei
    dst = sszutils.MarshalUint64(dst, uint64(t))
    return err
  }
  fn27 := func(t *phase0.DepositData) (err error) { // *phase0.DepositData
    // Field #0 'PublicKey'
    if err = fn25(t.PublicKey); err != nil {
      return err
    }
    // Field #1 'WithdrawalCredentials'
    if err = fn6(t.WithdrawalCredentials); err != nil {
      return err
    }
    // Field #2 'Amount'
    if err = fn26(t.Amount); err != nil {
      return err
    }
    // Field #3 'Signature'
    if err = fn4(t.Signature); err != nil {
      return err
    }
    return err
  }
  fn28 := func(t *phase0.Deposit) (err error) { // *phase0.Deposit
    // Field #0 'Proof'
    if err = fn24(t.Proof); err != nil {
      return err
    }
    // Field #1 'Data'
    if err = fn27(t.Data); err != nil {
      return err
    }
    return err
  }
  fn29 := func(t []*phase0.Deposit) (err error) { // []*phase0.Deposit
    vlen := len(t)
    for i := 0; i < vlen; i++ {
      if err = fn28(t[i]); err != nil {
        return err
      }
    }
    return err
  }
  fn30 := func(t *phase0.VoluntaryExit) (err error) { // *phase0.VoluntaryExit
    // Field #0 'Epoch'
    if err = fn15(t.Epoch); err != nil {
      return err
    }
    // Field #1 'ValidatorIndex'
    if err = fn2(t.ValidatorIndex); err != nil {
      return err
    }
    return err
  }
  fn31 := func(t *phase0.SignedVoluntaryExit) (err error) { // *phase0.SignedVoluntaryExit
    // Field #0 'Message'
    if err = fn30(t.Message); err != nil {
      return err
    }
    // Field #1 'Signature'
    if err = fn4(t.Signature); err != nil {
      return err
    }
    return err
  }
  fn32 := func(t []*phase0.SignedVoluntaryExit) (err error) { // []*phase0.SignedVoluntaryExit
    vlen := len(t)
    for i := 0; i < vlen; i++ {
      if err = fn31(t[i]); err != nil {
        return err
      }
    }
    return err
  }
  fn33 := func(t go_bitfield.Bitvector512) (err error) { // go_bitfield.Bitvector512:64:SYNC_COMMITTEE_SIZE/8
    hasLimit, limit, err := ds.ResolveSpecValue("SYNC_COMMITTEE_SIZE/8")
    if err != nil {
      return err
    }
    if !hasLimit {
      limit = 64
    }
    vlen := len(t)
    if vlen > int(limit) {
      return sszutils.ErrListTooBig
    }
    vlimit := int(limit)
    if vlimit > vlen {
      vlimit = vlen
    }
    dst = append(dst, t[:vlimit]...)
    if vlen < int(limit) {
      dst = sszutils.AppendZeroPadding(dst, int(limit) - vlen)
    }
    return err
  }
  fn34 := func(t *altair.SyncAggregate) (err error) { // *altair.SyncAggregate
    // Field #0 'SyncCommitteeBits'
    if err = fn33(t.SyncCommitteeBits); err != nil {
      return err
    }
    // Field #1 'SyncCommitteeSignature'
    if err = fn4(t.SyncCommitteeSignature); err != nil {
      return err
    }
    return err
  }
  fn35 := func(t phase0.Hash32) (err error) { // phase0.Hash32:32
    dst = append(dst, t[:32]...)
    return err
  }
  fn36 := func(t bellatrix.ExecutionAddress) (err error) { // bellatrix.ExecutionAddress:20
    dst = append(dst, t[:20]...)
    return err
  }
  fn37 := func(t [256]byte) (err error) { // [256]byte:256
    dst = append(dst, t[:256]...)
    return err
  }
  fn38 := func(t []byte) (err error) { // []byte
    dst = append(dst, t[:]...)
    return err
  }
  fn39 := func(t *uint256.Int) (err error) { // *uint256.Int:4
    vlen := len(t)
    for i := 0; i < vlen; i++ {
      if err = fn5(t[i]); err != nil {
        return err
      }
    }
    return err
  }
  fn40 := func(t bellatrix.Transaction) (err error) { // bellatrix.Transaction
    dst = append(dst, t[:]...)
    return err
  }
  fn41 := func(t []bellatrix.Transaction) (err error) { // []bellatrix.Transaction
    vlen := len(t)
    dstlen := len(dst)
    dst = sszutils.AppendZeroPadding(dst, vlen * 4)
    for i := 0; i < vlen; i++ {
      sszutils.UpdateOffset(dst[dstlen+(i*4):dstlen+((i+1)*4)], len(dst)-dstlen)
      if err = fn40(t[i]); err != nil {
        return err
      }
    }
    return err
  }
  fn42 := func(t capella.WithdrawalIndex) (err error) { // capella.WithdrawalIndex
    dst = sszutils.MarshalUint64(dst, uint64(t))
    return err
  }
  fn43 := func(t *capella.Withdrawal) (err error) { // *capella.Withdrawal
    // Field #0 'Index'
    if err = fn42(t.Index); err != nil {
      return err
    }
    // Field #1 'ValidatorIndex'
    if err = fn2(t.ValidatorIndex); err != nil {
      return err
    }
    // Field #2 'Address'
    if err = fn36(t.Address); err != nil {
      return err
    }
    // Field #3 'Amount'
    if err = fn26(t.Amount); err != nil {
      return err
    }
    return err
  }
  fn44 := func(t []*capella.Withdrawal) (err error) { // []*capella.Withdrawal
    vlen := len(t)
    for i := 0; i < vlen; i++ {
      if err = fn43(t[i]); err != nil {
        return err
      }
    }
    return err
  }
  fn45 := func(t *deneb.ExecutionPayload) (err error) { // *deneb.ExecutionPayload
    dstlen := len(dst)
    // Field #0 'ParentHash'
    if err = fn35(t.ParentHash); err != nil {
      return err
    }
    // Field #1 'FeeRecipient'
    if err = fn36(t.FeeRecipient); err != nil {
      return err
    }
    // Field #2 'StateRoot'
    if err = fn3(t.StateRoot); err != nil {
      return err
    }
    // Field #3 'ReceiptsRoot'
    if err = fn3(t.ReceiptsRoot); err != nil {
      return err
    }
    // Field #4 'LogsBloom'
    if err = fn37(t.LogsBloom); err != nil {
      return err
    }
    // Field #5 'PrevRandao'
    if err = fn8(t.PrevRandao); err != nil {
      return err
    }
    // Field #6 'BlockNumber'
    if err = fn5(t.BlockNumber); err != nil {
      return err
    }
    // Field #7 'GasLimit'
    if err = fn5(t.GasLimit); err != nil {
      return err
    }
    // Field #8 'GasUsed'
    if err = fn5(t.GasUsed); err != nil {
      return err
    }
    // Field #9 'Timestamp'
    if err = fn5(t.Timestamp); err != nil {
      return err
    }
    // Offset #10 'ExtraData'
    offset10 := len(dst)
    dst = sszutils.MarshalOffset(dst, 0)
    // Field #11 'BaseFeePerGas'
    if err = fn39(t.BaseFeePerGas); err != nil {
      return err
    }
    // Field #12 'BlockHash'
    if err = fn35(t.BlockHash); err != nil {
      return err
    }
    // Offset #13 'Transactions'
    offset13 := len(dst)
    dst = sszutils.MarshalOffset(dst, 0)
    // Offset #14 'Withdrawals'
    offset14 := len(dst)
    dst = sszutils.MarshalOffset(dst, 0)
    // Field #15 'BlobGasUsed'
    if err = fn5(t.BlobGasUsed); err != nil {
      return err
    }
    // Field #16 'ExcessBlobGas'
    if err = fn5(t.ExcessBlobGas); err != nil {
      return err
    }
    // Dynamic Field #10 'ExtraData'
    sszutils.UpdateOffset(dst[offset10:offset10+4], len(dst)-dstlen)
    if err = fn38(t.ExtraData); err != nil {
      return err
    }
    // Dynamic Field #13 'Transactions'
    sszutils.UpdateOffset(dst[offset13:offset13+4], len(dst)-dstlen)
    if err = fn41(t.Transactions); err != nil {
      return err
    }
    // Dynamic Field #14 'Withdrawals'
    sszutils.UpdateOffset(dst[offset14:offset14+4], len(dst)-dstlen)
    if err = fn44(t.Withdrawals); err != nil {
      return err
    }
    return err
  }
  fn46 := func(t *capella.BLSToExecutionChange) (err error) { // *capella.BLSToExecutionChange
    // Field #0 'ValidatorIndex'
    if err = fn2(t.ValidatorIndex); err != nil {
      return err
    }
    // Field #1 'FromBLSPubkey'
    if err = fn25(t.FromBLSPubkey); err != nil {
      return err
    }
    // Field #2 'ToExecutionAddress'
    if err = fn36(t.ToExecutionAddress); err != nil {
      return err
    }
    return err
  }
  fn47 := func(t *capella.SignedBLSToExecutionChange) (err error) { // *capella.SignedBLSToExecutionChange
    // Field #0 'Message'
    if err = fn46(t.Message); err != nil {
      return err
    }
    // Field #1 'Signature'
    if err = fn4(t.Signature); err != nil {
      return err
    }
    return err
  }
  fn48 := func(t []*capella.SignedBLSToExecutionChange) (err error) { // []*capella.SignedBLSToExecutionChange
    vlen := len(t)
    for i := 0; i < vlen; i++ {
      if err = fn47(t[i]); err != nil {
        return err
      }
    }
    return err
  }
  fn49 := func(t deneb.KZGCommitment) (err error) { // deneb.KZGCommitment:48
    dst = append(dst, t[:48]...)
    return err
  }
  fn50 := func(t []deneb.KZGCommitment) (err error) { // []deneb.KZGCommitment:48
    vlen := len(t)
    for i := 0; i < vlen; i++ {
      if err = fn49(t[i]); err != nil {
        return err
      }
    }
    return err
  }
  fn51 := func(t *deneb.BeaconBlockBody) (err error) { // *deneb.BeaconBlockBody
    dstlen := len(dst)
    // Field #0 'RANDAOReveal'
    if err = fn4(t.RANDAOReveal); err != nil {
      return err
    }
    // Field #1 'ETH1Data'
    if err = fn7(t.ETH1Data); err != nil {
      return err
    }
    // Field #2 'Graffiti'
    if err = fn8(t.Graffiti); err != nil {
      return err
    }
    // Offset #3 'ProposerSlashings'
    offset3 := len(dst)
    dst = sszutils.MarshalOffset(dst, 0)
    // Offset #4 'AttesterSlashings'
    offset4 := len(dst)
    dst = sszutils.MarshalOffset(dst, 0)
    // Offset #5 'Attestations'
    offset5 := len(dst)
    dst = sszutils.MarshalOffset(dst, 0)
    // Offset #6 'Deposits'
    offset6 := len(dst)
    dst = sszutils.MarshalOffset(dst, 0)
    // Offset #7 'VoluntaryExits'
    offset7 := len(dst)
    dst = sszutils.MarshalOffset(dst, 0)
    // Field #8 'SyncAggregate'
    if err = fn34(t.SyncAggregate); err != nil {
      return err
    }
    // Offset #9 'ExecutionPayload'
    offset9 := len(dst)
    dst = sszutils.MarshalOffset(dst, 0)
    // Offset #10 'BLSToExecutionChanges'
    offset10 := len(dst)
    dst = sszutils.MarshalOffset(dst, 0)
    // Offset #11 'BlobKZGCommitments'
    offset11 := len(dst)
    dst = sszutils.MarshalOffset(dst, 0)
    // Dynamic Field #3 'ProposerSlashings'
    sszutils.UpdateOffset(dst[offset3:offset3+4], len(dst)-dstlen)
    if err = fn12(t.ProposerSlashings); err != nil {
      return err
    }
    // Dynamic Field #4 'AttesterSlashings'
    sszutils.UpdateOffset(dst[offset4:offset4+4], len(dst)-dstlen)
    if err = fn20(t.AttesterSlashings); err != nil {
      return err
    }
    // Dynamic Field #5 'Attestations'
    sszutils.UpdateOffset(dst[offset5:offset5+4], len(dst)-dstlen)
    if err = fn23(t.Attestations); err != nil {
      return err
    }
    // Dynamic Field #6 'Deposits'
    sszutils.UpdateOffset(dst[offset6:offset6+4], len(dst)-dstlen)
    if err = fn29(t.Deposits); err != nil {
      return err
    }
    // Dynamic Field #7 'VoluntaryExits'
    sszutils.UpdateOffset(dst[offset7:offset7+4], len(dst)-dstlen)
    if err = fn32(t.VoluntaryExits); err != nil {
      return err
    }
    // Dynamic Field #9 'ExecutionPayload'
    sszutils.UpdateOffset(dst[offset9:offset9+4], len(dst)-dstlen)
    if err = fn45(t.ExecutionPayload); err != nil {
      return err
    }
    // Dynamic Field #10 'BLSToExecutionChanges'
    sszutils.UpdateOffset(dst[offset10:offset10+4], len(dst)-dstlen)
    if err = fn48(t.BLSToExecutionChanges); err != nil {
      return err
    }
    // Dynamic Field #11 'BlobKZGCommitments'
    sszutils.UpdateOffset(dst[offset11:offset11+4], len(dst)-dstlen)
    if err = fn50(t.BlobKZGCommitments); err != nil {
      return err
    }
    return err
  }
  fn52 := func(t *deneb.BeaconBlock) (err error) { // *deneb.BeaconBlock
    dstlen := len(dst)
    // Field #0 'Slot'
    if err = fn1(t.Slot); err != nil {
      return err
    }
    // Field #1 'ProposerIndex'
    if err = fn2(t.ProposerIndex); err != nil {
      return err
    }
    // Field #2 'ParentRoot'
    if err = fn3(t.ParentRoot); err != nil {
      return err
    }
    // Field #3 'StateRoot'
    if err = fn3(t.StateRoot); err != nil {
      return err
    }
    // Offset #4 'Body'
    offset4 := len(dst)
    dst = sszutils.MarshalOffset(dst, 0)
    // Dynamic Field #4 'Body'
    sszutils.UpdateOffset(dst[offset4:offset4+4], len(dst)-dstlen)
    if err = fn51(t.Body); err != nil {
      return err
    }
    return err
  }
  fn53 := func(t *TestBeaconBlock) (err error) { // *TestBeaconBlock
    dstlen := len(dst)
    // Offset #0 'Message'
    offset0 := len(dst)
    dst = sszutils.MarshalOffset(dst, 0)
    // Field #1 'Signature'
    if err = fn4(t.Signature); err != nil {
      return err
    }
    // Dynamic Field #0 'Message'
    sszutils.UpdateOffset(dst[offset0:offset0+4], len(dst)-dstlen)
    if err = fn52(t.Message); err != nil {
      return err
    }
    return err
  }
  err = fn53(t)
  return dst, err
}
func (t *TestBeaconBlock) MarshalSSZ() ([]byte, error) {
  return dynssz.GetGlobalDynSsz().MarshalSSZ(t)
}
func (t *TestBeaconBlock) MarshalSSZTo(buf []byte) (dst []byte, err error) {
  return t.MarshalSSZDyn(dynssz.GetGlobalDynSsz(), buf)
}


func (t *TestBeaconBlock) SizeSSZDyn(ds *dynssz.DynSsz) (size int) {
  sfn1 := func(t []*phase0.ProposerSlashing) (size int) { // []*phase0.ProposerSlashing
    size += len(t) * 416
    return size
  }
  sfn2 := func(t []uint64) (size int) { // []uint64
    size += len(t) * 8
    return size
  }
  sfn3 := func(t *phase0.IndexedAttestation) (size int) { // *phase0.IndexedAttestation
    size = 224
    size += 4 + sfn2(t.AttestingIndices)
    return size
  }
  sfn4 := func(t *phase0.AttesterSlashing) (size int) { // *phase0.AttesterSlashing
    size = 0
    size += 4 + sfn3(t.Attestation1)
    size += 4 + sfn3(t.Attestation2)
    return size
  }
  sfn5 := func(t []*phase0.AttesterSlashing) (size int) { // []*phase0.AttesterSlashing
    vlen := len(t)
    for i := 0; i < vlen; i++ {
      size += 4 + sfn4(t[i])
    }
    return size
  }
  sfn6 := func(t go_bitfield.Bitlist) (size int) { // go_bitfield.Bitlist
    size += len(t)
    return size
  }
  sfn7 := func(t *phase0.Attestation) (size int) { // *phase0.Attestation
    size = 224
    size += 4 + sfn6(t.AggregationBits)
    return size
  }
  sfn8 := func(t []*phase0.Attestation) (size int) { // []*phase0.Attestation
    vlen := len(t)
    for i := 0; i < vlen; i++ {
      size += 4 + sfn7(t[i])
    }
    return size
  }
  sfn9 := func(t [][]byte) (size int) { // [][]byte:33:DEPOSIT_CONTRACT_TREE_DEPTH+1:32
    hasLimit, limit, _ := ds.ResolveSpecValue("DEPOSIT_CONTRACT_TREE_DEPTH+1")
    if !hasLimit {
      limit = 33
    }
    size += int(limit) * 32
    return size
  }
  sfn10 := func(t *phase0.Deposit) (size int) { // *phase0.Deposit
    size = 184
    size += sfn9(t.Proof)
    return size
  }
  sfn11 := func(t []*phase0.Deposit) (size int) { // []*phase0.Deposit
    if len(t) > 0 {
      size += len(t) * sfn10(t[0])
    }
    return size
  }
  sfn12 := func(t []*phase0.SignedVoluntaryExit) (size int) { // []*phase0.SignedVoluntaryExit
    size += len(t) * 112
    return size
  }
  sfn13 := func(t go_bitfield.Bitvector512) (size int) { // go_bitfield.Bitvector512:64:SYNC_COMMITTEE_SIZE/8
    hasLimit, limit, _ := ds.ResolveSpecValue("SYNC_COMMITTEE_SIZE/8")
    if !hasLimit {
      limit = 64
    }
    size += int(limit) * 1
    return size
  }
  sfn14 := func(t *altair.SyncAggregate) (size int) { // *altair.SyncAggregate
    size = 96
    size += sfn13(t.SyncCommitteeBits)
    return size
  }
  sfn15 := func(t []byte) (size int) { // []byte
    size += len(t)
    return size
  }
  sfn16 := func(t bellatrix.Transaction) (size int) { // bellatrix.Transaction
    size += len(t)
    return size
  }
  sfn17 := func(t []bellatrix.Transaction) (size int) { // []bellatrix.Transaction
    vlen := len(t)
    for i := 0; i < vlen; i++ {
      size += 4 + sfn16(t[i])
    }
    return size
  }
  sfn18 := func(t []*capella.Withdrawal) (size int) { // []*capella.Withdrawal
    size += len(t) * 44
    return size
  }
  sfn19 := func(t *deneb.ExecutionPayload) (size int) { // *deneb.ExecutionPayload
    size = 516
    size += 4 + sfn15(t.ExtraData)
    size += 4 + sfn17(t.Transactions)
    size += 4 + sfn18(t.Withdrawals)
    return size
  }
  sfn20 := func(t []*capella.SignedBLSToExecutionChange) (size int) { // []*capella.SignedBLSToExecutionChange
    size += len(t) * 172
    return size
  }
  sfn21 := func(t []deneb.KZGCommitment) (size int) { // []deneb.KZGCommitment:48
    size += len(t) * 48
    return size
  }
  sfn22 := func(t *deneb.BeaconBlockBody) (size int) { // *deneb.BeaconBlockBody
    size = 200
    size += 4 + sfn1(t.ProposerSlashings)
    size += 4 + sfn5(t.AttesterSlashings)
    size += 4 + sfn8(t.Attestations)
    size += 4 + sfn11(t.Deposits)
    size += 4 + sfn12(t.VoluntaryExits)
    size += sfn14(t.SyncAggregate)
    size += 4 + sfn19(t.ExecutionPayload)
    size += 4 + sfn20(t.BLSToExecutionChanges)
    size += 4 + sfn21(t.BlobKZGCommitments)
    return size
  }
  sfn23 := func(t *deneb.BeaconBlock) (size int) { // *deneb.BeaconBlock
    size = 80
    size += 4 + sfn22(t.Body)
    return size
  }
  sfn24 := func(t *TestBeaconBlock) (size int) { // *TestBeaconBlock
    size = 96
    size += 4 + sfn23(t.Message)
    return size
  }
  return sfn24(t)
}
func (t *TestBeaconBlock) SizeSSZ() (size int) {
  return t.SizeSSZDyn(dynssz.GetGlobalDynSsz())
}


func (t *TestBeaconBlock) UnmarshalSSZDyn(ds *dynssz.DynSsz, buf []byte) (err error) {
  sfn1 := func() (size int) { // [][]byte:33:DEPOSIT_CONTRACT_TREE_DEPTH+1:32
    hasLimit, limit, _ := ds.ResolveSpecValue("DEPOSIT_CONTRACT_TREE_DEPTH+1")
    if !hasLimit {
      limit = 33
    }
    size += int(limit) * 32
    return size
  }()
  sfn2 := func() (size int) { // *phase0.Deposit
    size = 184
    size += sfn1
    return size
  }()
  sfn3 := func() (size int) { // go_bitfield.Bitvector512:64:SYNC_COMMITTEE_SIZE/8
    hasLimit, limit, _ := ds.ResolveSpecValue("SYNC_COMMITTEE_SIZE/8")
    if !hasLimit {
      limit = 64
    }
    size += int(limit) * 1
    return size
  }()
  sfn4 := func() (size int) { // *altair.SyncAggregate
    size = 96
    size += sfn3
    return size
  }()
  fn1 := func(_ phase0.Slot, buf []byte) (phase0.Slot, error) { // phase0.Slot
    var err error
    var t phase0.Slot
    t = (phase0.Slot)(sszutils.UnmarshallUint64(buf))
    return t, err
  }
  fn2 := func(_ phase0.ValidatorIndex, buf []byte) (phase0.ValidatorIndex, error) { // phase0.ValidatorIndex
    var err error
    var t phase0.ValidatorIndex
    t = (phase0.ValidatorIndex)(sszutils.UnmarshallUint64(buf))
    return t, err
  }
  fn3 := func(t phase0.Root, buf []byte) (phase0.Root, error) { // phase0.Root:32
    var err error
    itemsize := 1
    limit := 32
    if len(buf) > int(limit) * itemsize {
      return t, sszutils.ErrListTooBig
    }
    copy(t[:], buf[:])
    return t, err
  }
  fn4 := func(t phase0.BLSSignature, buf []byte) (phase0.BLSSignature, error) { // phase0.BLSSignature:96
    var err error
    itemsize := 1
    limit := 96
    if len(buf) > int(limit) * itemsize {
      return t, sszutils.ErrListTooBig
    }
    copy(t[:], buf[:])
    return t, err
  }
  fn5 := func(_ uint64, buf []byte) (uint64, error) { // uint64
    var err error
    var t uint64
    t = (uint64)(sszutils.UnmarshallUint64(buf))
    return t, err
  }
  fn6 := func(t []byte, buf []byte) ([]byte, error) { // []byte:32
    var err error
    itemsize := 1
    limit := 32
    if len(t) < int(limit) {
      t = make([]byte, int(limit))
    } else {
      t = t[:int(limit)]
    }
    if len(buf) > int(limit) * itemsize {
      return t, sszutils.ErrListTooBig
    }
    copy(t[:], buf[:])
    return t, err
  }
  fn7 := func(t *phase0.ETH1Data, buf []byte) (*phase0.ETH1Data, error) { // *phase0.ETH1Data
    var err error
    if t == nil {
      t = new(phase0.ETH1Data)
    }
    bufpos := 0
    buflen := len(buf)
    minsize := 72
    if buflen < minsize {
      return t, sszutils.ErrUnexpectedEOF
    }
    // Field #0 'DepositRoot'
    {
      fieldsize := 32
      if t.DepositRoot, err = fn3(t.DepositRoot, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #1 'DepositCount'
    {
      fieldsize := 8
      if t.DepositCount, err = fn5(t.DepositCount, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #2 'BlockHash'
    {
      fieldsize := 32
      if t.BlockHash, err = fn6(t.BlockHash, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    return t, err
  }
  fn8 := func(t [32]byte, buf []byte) ([32]byte, error) { // [32]byte:32
    var err error
    itemsize := 1
    limit := 32
    if len(buf) > int(limit) * itemsize {
      return t, sszutils.ErrListTooBig
    }
    copy(t[:], buf[:])
    return t, err
  }
  fn9 := func(t *phase0.BeaconBlockHeader, buf []byte) (*phase0.BeaconBlockHeader, error) { // *phase0.BeaconBlockHeader
    var err error
    if t == nil {
      t = new(phase0.BeaconBlockHeader)
    }
    bufpos := 0
    buflen := len(buf)
    minsize := 112
    if buflen < minsize {
      return t, sszutils.ErrUnexpectedEOF
    }
    // Field #0 'Slot'
    {
      fieldsize := 8
      if t.Slot, err = fn1(t.Slot, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #1 'ProposerIndex'
    {
      fieldsize := 8
      if t.ProposerIndex, err = fn2(t.ProposerIndex, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #2 'ParentRoot'
    {
      fieldsize := 32
      if t.ParentRoot, err = fn3(t.ParentRoot, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #3 'StateRoot'
    {
      fieldsize := 32
      if t.StateRoot, err = fn3(t.StateRoot, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #4 'BodyRoot'
    {
      fieldsize := 32
      if t.BodyRoot, err = fn3(t.BodyRoot, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    return t, err
  }
  fn10 := func(t *phase0.SignedBeaconBlockHeader, buf []byte) (*phase0.SignedBeaconBlockHeader, error) { // *phase0.SignedBeaconBlockHeader
    var err error
    if t == nil {
      t = new(phase0.SignedBeaconBlockHeader)
    }
    bufpos := 0
    buflen := len(buf)
    minsize := 208
    if buflen < minsize {
      return t, sszutils.ErrUnexpectedEOF
    }
    // Field #0 'Message'
    {
      fieldsize := 112
      if t.Message, err = fn9(t.Message, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #1 'Signature'
    {
      fieldsize := 96
      if t.Signature, err = fn4(t.Signature, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    return t, err
  }
  fn11 := func(t *phase0.ProposerSlashing, buf []byte) (*phase0.ProposerSlashing, error) { // *phase0.ProposerSlashing
    var err error
    if t == nil {
      t = new(phase0.ProposerSlashing)
    }
    bufpos := 0
    buflen := len(buf)
    minsize := 416
    if buflen < minsize {
      return t, sszutils.ErrUnexpectedEOF
    }
    // Field #0 'SignedHeader1'
    {
      fieldsize := 208
      if t.SignedHeader1, err = fn10(t.SignedHeader1, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #1 'SignedHeader2'
    {
      fieldsize := 208
      if t.SignedHeader2, err = fn10(t.SignedHeader2, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    return t, err
  }
  fn12 := func(t []*phase0.ProposerSlashing, buf []byte) ([]*phase0.ProposerSlashing, error) { // []*phase0.ProposerSlashing
    var err error
    buflen := len(buf)
    itemsize := 416
    itemCount := buflen / itemsize
    if buflen % itemsize != 0 {
      return t, sszutils.ErrUnexpectedEOF
    }
    if len(t) < itemCount {
      t = make([]*phase0.ProposerSlashing, itemCount)
    } else {
      t = t[:itemCount]
    }
    for i := 0; i < itemCount; i++ {
      if t[i], err = fn11(t[i], buf[i*itemsize:(i+1)*itemsize]); err != nil {
        return t, err
      }
    }
    return t, err
  }
  fn13 := func(t []uint64, buf []byte) ([]uint64, error) { // []uint64
    var err error
    buflen := len(buf)
    itemsize := 8
    itemCount := buflen / itemsize
    if buflen % itemsize != 0 {
      return t, sszutils.ErrUnexpectedEOF
    }
    if len(t) < itemCount {
      t = make([]uint64, itemCount)
    } else {
      t = t[:itemCount]
    }
    for i := 0; i < itemCount; i++ {
      if t[i], err = fn5(t[i], buf[i*itemsize:(i+1)*itemsize]); err != nil {
        return t, err
      }
    }
    return t, err
  }
  fn14 := func(_ phase0.CommitteeIndex, buf []byte) (phase0.CommitteeIndex, error) { // phase0.CommitteeIndex
    var err error
    var t phase0.CommitteeIndex
    t = (phase0.CommitteeIndex)(sszutils.UnmarshallUint64(buf))
    return t, err
  }
  fn15 := func(_ phase0.Epoch, buf []byte) (phase0.Epoch, error) { // phase0.Epoch
    var err error
    var t phase0.Epoch
    t = (phase0.Epoch)(sszutils.UnmarshallUint64(buf))
    return t, err
  }
  fn16 := func(t *phase0.Checkpoint, buf []byte) (*phase0.Checkpoint, error) { // *phase0.Checkpoint
    var err error
    if t == nil {
      t = new(phase0.Checkpoint)
    }
    bufpos := 0
    buflen := len(buf)
    minsize := 40
    if buflen < minsize {
      return t, sszutils.ErrUnexpectedEOF
    }
    // Field #0 'Epoch'
    {
      fieldsize := 8
      if t.Epoch, err = fn15(t.Epoch, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #1 'Root'
    {
      fieldsize := 32
      if t.Root, err = fn3(t.Root, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    return t, err
  }
  fn17 := func(t *phase0.AttestationData, buf []byte) (*phase0.AttestationData, error) { // *phase0.AttestationData
    var err error
    if t == nil {
      t = new(phase0.AttestationData)
    }
    bufpos := 0
    buflen := len(buf)
    minsize := 128
    if buflen < minsize {
      return t, sszutils.ErrUnexpectedEOF
    }
    // Field #0 'Slot'
    {
      fieldsize := 8
      if t.Slot, err = fn1(t.Slot, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #1 'Index'
    {
      fieldsize := 8
      if t.Index, err = fn14(t.Index, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #2 'BeaconBlockRoot'
    {
      fieldsize := 32
      if t.BeaconBlockRoot, err = fn3(t.BeaconBlockRoot, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #3 'Source'
    {
      fieldsize := 40
      if t.Source, err = fn16(t.Source, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #4 'Target'
    {
      fieldsize := 40
      if t.Target, err = fn16(t.Target, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    return t, err
  }
  fn18 := func(t *phase0.IndexedAttestation, buf []byte) (*phase0.IndexedAttestation, error) { // *phase0.IndexedAttestation
    var err error
    if t == nil {
      t = new(phase0.IndexedAttestation)
    }
    bufpos := 0
    buflen := len(buf)
    minsize := 228
    if buflen < minsize {
      return t, sszutils.ErrUnexpectedEOF
    }
    // Offset #0 'AttestingIndices'
    offset0 := int(sszutils.ReadOffset(buf[bufpos:bufpos+4]))
    bufpos += 4
    // Field #1 'Data'
    {
      fieldsize := 128
      if t.Data, err = fn17(t.Data, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #2 'Signature'
    {
      fieldsize := 96
      if t.Signature, err = fn4(t.Signature, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Dynamic Field #0 'AttestingIndices'
    if offset0 < bufpos  {
      return t, sszutils.ErrOffset
    }
    {
      fieldSlice := buf[offset0:]
      if t.AttestingIndices, err = fn13(t.AttestingIndices, fieldSlice); err != nil {
        return t, err
      }
      bufpos += len(fieldSlice)
    }
    return t, err
  }
  fn19 := func(t *phase0.AttesterSlashing, buf []byte) (*phase0.AttesterSlashing, error) { // *phase0.AttesterSlashing
    var err error
    if t == nil {
      t = new(phase0.AttesterSlashing)
    }
    bufpos := 0
    buflen := len(buf)
    minsize := 8
    if buflen < minsize {
      return t, sszutils.ErrUnexpectedEOF
    }
    // Offset #0 'Attestation1'
    offset0 := int(sszutils.ReadOffset(buf[bufpos:bufpos+4]))
    bufpos += 4
    // Offset #1 'Attestation2'
    offset1 := int(sszutils.ReadOffset(buf[bufpos:bufpos+4]))
    bufpos += 4
    // Dynamic Field #0 'Attestation1'
    if offset0 < bufpos || offset1 > buflen || offset1 < offset0 {
      return t, sszutils.ErrOffset
    }
    {
      fieldSlice := buf[offset0:offset1]
      if t.Attestation1, err = fn18(t.Attestation1, fieldSlice); err != nil {
        return t, err
      }
      bufpos += len(fieldSlice)
    }
    // Dynamic Field #1 'Attestation2'
    if offset1 < bufpos  {
      return t, sszutils.ErrOffset
    }
    {
      fieldSlice := buf[offset1:]
      if t.Attestation2, err = fn18(t.Attestation2, fieldSlice); err != nil {
        return t, err
      }
      bufpos += len(fieldSlice)
    }
    return t, err
  }
  fn20 := func(t []*phase0.AttesterSlashing, buf []byte) ([]*phase0.AttesterSlashing, error) { // []*phase0.AttesterSlashing
    var err error
    buflen := len(buf)
    if buflen == 0 {
      return t, nil
    }
    if buflen < 4 {
      return t, sszutils.ErrUnexpectedEOF
    }
    offset := int(sszutils.ReadOffset(buf[0:4]))
    itemCount := offset / 4
    if buflen < itemCount * 4 {
      return t, sszutils.ErrUnexpectedEOF
    }
    if len(t) < itemCount {
      t = make([]*phase0.AttesterSlashing, itemCount)
    } else {
      t = t[:itemCount]
    }
    var endOffset int
    for i := 0; i < itemCount; i++ {
      if i < itemCount-1 {
        endOffset = int(sszutils.ReadOffset(buf[(i+1)*4:(i+2)*4]))
      } else {
        endOffset = buflen
      }
      if endOffset < offset || endOffset > buflen {
        return t, sszutils.ErrOffset
      }
      if t[i], err = fn19(t[i], buf[offset:endOffset]); err != nil {
        return t, err
      }
      offset = endOffset
    }
    return t, err
  }
  fn21 := func(t go_bitfield.Bitlist, buf []byte) (go_bitfield.Bitlist, error) { // go_bitfield.Bitlist
    var err error
    if len(t) < len(buf) {
      t = make(go_bitfield.Bitlist, len(buf))
    } else {
      t = t[:len(buf)]
    }
    if len(buf) > 0 {
      copy(t[:], buf[:])
    }
    return t, err
  }
  fn22 := func(t *phase0.Attestation, buf []byte) (*phase0.Attestation, error) { // *phase0.Attestation
    var err error
    if t == nil {
      t = new(phase0.Attestation)
    }
    bufpos := 0
    buflen := len(buf)
    minsize := 228
    if buflen < minsize {
      return t, sszutils.ErrUnexpectedEOF
    }
    // Offset #0 'AggregationBits'
    offset0 := int(sszutils.ReadOffset(buf[bufpos:bufpos+4]))
    bufpos += 4
    // Field #1 'Data'
    {
      fieldsize := 128
      if t.Data, err = fn17(t.Data, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #2 'Signature'
    {
      fieldsize := 96
      if t.Signature, err = fn4(t.Signature, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Dynamic Field #0 'AggregationBits'
    if offset0 < bufpos  {
      return t, sszutils.ErrOffset
    }
    {
      fieldSlice := buf[offset0:]
      if t.AggregationBits, err = fn21(t.AggregationBits, fieldSlice); err != nil {
        return t, err
      }
      bufpos += len(fieldSlice)
    }
    return t, err
  }
  fn23 := func(t []*phase0.Attestation, buf []byte) ([]*phase0.Attestation, error) { // []*phase0.Attestation
    var err error
    buflen := len(buf)
    if buflen == 0 {
      return t, nil
    }
    if buflen < 4 {
      return t, sszutils.ErrUnexpectedEOF
    }
    offset := int(sszutils.ReadOffset(buf[0:4]))
    itemCount := offset / 4
    if buflen < itemCount * 4 {
      return t, sszutils.ErrUnexpectedEOF
    }
    if len(t) < itemCount {
      t = make([]*phase0.Attestation, itemCount)
    } else {
      t = t[:itemCount]
    }
    var endOffset int
    for i := 0; i < itemCount; i++ {
      if i < itemCount-1 {
        endOffset = int(sszutils.ReadOffset(buf[(i+1)*4:(i+2)*4]))
      } else {
        endOffset = buflen
      }
      if endOffset < offset || endOffset > buflen {
        return t, sszutils.ErrOffset
      }
      if t[i], err = fn22(t[i], buf[offset:endOffset]); err != nil {
        return t, err
      }
      offset = endOffset
    }
    return t, err
  }
  fn24 := func(t [][]byte, buf []byte) ([][]byte, error) { // [][]byte:33:DEPOSIT_CONTRACT_TREE_DEPTH+1:32
    var err error
    itemsize := 32
    limit := sfn1 / itemsize
    if len(t) < int(limit) {
      t = make([][]byte, int(limit))
    } else {
      t = t[:int(limit)]
    }
    if len(buf) > int(limit) * itemsize {
      return t, sszutils.ErrListTooBig
    }
    for i := 0; i < int(limit); i++ {
      if t[i], err = fn6(t[i], buf[i*itemsize:(i+1)*itemsize]); err != nil {
        return t, err
      }
    }
    return t, err
  }
  fn25 := func(t phase0.BLSPubKey, buf []byte) (phase0.BLSPubKey, error) { // phase0.BLSPubKey:48
    var err error
    itemsize := 1
    limit := 48
    if len(buf) > int(limit) * itemsize {
      return t, sszutils.ErrListTooBig
    }
    copy(t[:], buf[:])
    return t, err
  }
  fn26 := func(_ phase0.Gwei, buf []byte) (phase0.Gwei, error) { // phase0.Gwei
    var err error
    var t phase0.Gwei
    t = (phase0.Gwei)(sszutils.UnmarshallUint64(buf))
    return t, err
  }
  fn27 := func(t *phase0.DepositData, buf []byte) (*phase0.DepositData, error) { // *phase0.DepositData
    var err error
    if t == nil {
      t = new(phase0.DepositData)
    }
    bufpos := 0
    buflen := len(buf)
    minsize := 184
    if buflen < minsize {
      return t, sszutils.ErrUnexpectedEOF
    }
    // Field #0 'PublicKey'
    {
      fieldsize := 48
      if t.PublicKey, err = fn25(t.PublicKey, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #1 'WithdrawalCredentials'
    {
      fieldsize := 32
      if t.WithdrawalCredentials, err = fn6(t.WithdrawalCredentials, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #2 'Amount'
    {
      fieldsize := 8
      if t.Amount, err = fn26(t.Amount, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #3 'Signature'
    {
      fieldsize := 96
      if t.Signature, err = fn4(t.Signature, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    return t, err
  }
  fn28 := func(t *phase0.Deposit, buf []byte) (*phase0.Deposit, error) { // *phase0.Deposit
    var err error
    if t == nil {
      t = new(phase0.Deposit)
    }
    bufpos := 0
    buflen := len(buf)
    minsize := 184
    if buflen < minsize {
      return t, sszutils.ErrUnexpectedEOF
    }
    // Field #0 'Proof'
    {
      fieldsize := sfn1
      minsize += fieldsize
      if buflen < minsize {
        return t, sszutils.ErrUnexpectedEOF
      }
      if t.Proof, err = fn24(t.Proof, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #1 'Data'
    {
      fieldsize := 184
      if t.Data, err = fn27(t.Data, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    return t, err
  }
  fn29 := func(t []*phase0.Deposit, buf []byte) ([]*phase0.Deposit, error) { // []*phase0.Deposit
    var err error
    buflen := len(buf)
    itemsize := sfn2
    itemCount := buflen / itemsize
    if buflen % itemsize != 0 {
      return t, sszutils.ErrUnexpectedEOF
    }
    if len(t) < itemCount {
      t = make([]*phase0.Deposit, itemCount)
    } else {
      t = t[:itemCount]
    }
    for i := 0; i < itemCount; i++ {
      if t[i], err = fn28(t[i], buf[i*itemsize:(i+1)*itemsize]); err != nil {
        return t, err
      }
    }
    return t, err
  }
  fn30 := func(t *phase0.VoluntaryExit, buf []byte) (*phase0.VoluntaryExit, error) { // *phase0.VoluntaryExit
    var err error
    if t == nil {
      t = new(phase0.VoluntaryExit)
    }
    bufpos := 0
    buflen := len(buf)
    minsize := 16
    if buflen < minsize {
      return t, sszutils.ErrUnexpectedEOF
    }
    // Field #0 'Epoch'
    {
      fieldsize := 8
      if t.Epoch, err = fn15(t.Epoch, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #1 'ValidatorIndex'
    {
      fieldsize := 8
      if t.ValidatorIndex, err = fn2(t.ValidatorIndex, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    return t, err
  }
  fn31 := func(t *phase0.SignedVoluntaryExit, buf []byte) (*phase0.SignedVoluntaryExit, error) { // *phase0.SignedVoluntaryExit
    var err error
    if t == nil {
      t = new(phase0.SignedVoluntaryExit)
    }
    bufpos := 0
    buflen := len(buf)
    minsize := 112
    if buflen < minsize {
      return t, sszutils.ErrUnexpectedEOF
    }
    // Field #0 'Message'
    {
      fieldsize := 16
      if t.Message, err = fn30(t.Message, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #1 'Signature'
    {
      fieldsize := 96
      if t.Signature, err = fn4(t.Signature, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    return t, err
  }
  fn32 := func(t []*phase0.SignedVoluntaryExit, buf []byte) ([]*phase0.SignedVoluntaryExit, error) { // []*phase0.SignedVoluntaryExit
    var err error
    buflen := len(buf)
    itemsize := 112
    itemCount := buflen / itemsize
    if buflen % itemsize != 0 {
      return t, sszutils.ErrUnexpectedEOF
    }
    if len(t) < itemCount {
      t = make([]*phase0.SignedVoluntaryExit, itemCount)
    } else {
      t = t[:itemCount]
    }
    for i := 0; i < itemCount; i++ {
      if t[i], err = fn31(t[i], buf[i*itemsize:(i+1)*itemsize]); err != nil {
        return t, err
      }
    }
    return t, err
  }
  fn33 := func(t go_bitfield.Bitvector512, buf []byte) (go_bitfield.Bitvector512, error) { // go_bitfield.Bitvector512:64:SYNC_COMMITTEE_SIZE/8
    var err error
    itemsize := 1
    limit := sfn3 / itemsize
    if len(t) < int(limit) {
      t = make(go_bitfield.Bitvector512, int(limit))
    } else {
      t = t[:int(limit)]
    }
    if len(buf) > int(limit) * itemsize {
      return t, sszutils.ErrListTooBig
    }
    copy(t[:], buf[:])
    return t, err
  }
  fn34 := func(t *altair.SyncAggregate, buf []byte) (*altair.SyncAggregate, error) { // *altair.SyncAggregate
    var err error
    if t == nil {
      t = new(altair.SyncAggregate)
    }
    bufpos := 0
    buflen := len(buf)
    minsize := 96
    if buflen < minsize {
      return t, sszutils.ErrUnexpectedEOF
    }
    // Field #0 'SyncCommitteeBits'
    {
      fieldsize := sfn3
      minsize += fieldsize
      if buflen < minsize {
        return t, sszutils.ErrUnexpectedEOF
      }
      if t.SyncCommitteeBits, err = fn33(t.SyncCommitteeBits, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #1 'SyncCommitteeSignature'
    {
      fieldsize := 96
      if t.SyncCommitteeSignature, err = fn4(t.SyncCommitteeSignature, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    return t, err
  }
  fn35 := func(t phase0.Hash32, buf []byte) (phase0.Hash32, error) { // phase0.Hash32:32
    var err error
    itemsize := 1
    limit := 32
    if len(buf) > int(limit) * itemsize {
      return t, sszutils.ErrListTooBig
    }
    copy(t[:], buf[:])
    return t, err
  }
  fn36 := func(t bellatrix.ExecutionAddress, buf []byte) (bellatrix.ExecutionAddress, error) { // bellatrix.ExecutionAddress:20
    var err error
    itemsize := 1
    limit := 20
    if len(buf) > int(limit) * itemsize {
      return t, sszutils.ErrListTooBig
    }
    copy(t[:], buf[:])
    return t, err
  }
  fn37 := func(t [256]byte, buf []byte) ([256]byte, error) { // [256]byte:256
    var err error
    itemsize := 1
    limit := 256
    if len(buf) > int(limit) * itemsize {
      return t, sszutils.ErrListTooBig
    }
    copy(t[:], buf[:])
    return t, err
  }
  fn38 := func(t []byte, buf []byte) ([]byte, error) { // []byte
    var err error
    if len(t) < len(buf) {
      t = make([]byte, len(buf))
    } else {
      t = t[:len(buf)]
    }
    if len(buf) > 0 {
      copy(t[:], buf[:])
    }
    return t, err
  }
  fn39 := func(t *uint256.Int, buf []byte) (*uint256.Int, error) { // *uint256.Int:4
    var err error
    if t == nil {
      t = new(uint256.Int)
    }
    itemsize := 8
    limit := 4
    if len(buf) > int(limit) * itemsize {
      return t, sszutils.ErrListTooBig
    }
    for i := 0; i < int(limit); i++ {
      if t[i], err = fn5(t[i], buf[i*itemsize:(i+1)*itemsize]); err != nil {
        return t, err
      }
    }
    return t, err
  }
  fn40 := func(t bellatrix.Transaction, buf []byte) (bellatrix.Transaction, error) { // bellatrix.Transaction
    var err error
    if len(t) < len(buf) {
      t = make(bellatrix.Transaction, len(buf))
    } else {
      t = t[:len(buf)]
    }
    if len(buf) > 0 {
      copy(t[:], buf[:])
    }
    return t, err
  }
  fn41 := func(t []bellatrix.Transaction, buf []byte) ([]bellatrix.Transaction, error) { // []bellatrix.Transaction
    var err error
    buflen := len(buf)
    if buflen == 0 {
      return t, nil
    }
    if buflen < 4 {
      return t, sszutils.ErrUnexpectedEOF
    }
    offset := int(sszutils.ReadOffset(buf[0:4]))
    itemCount := offset / 4
    if buflen < itemCount * 4 {
      return t, sszutils.ErrUnexpectedEOF
    }
    if len(t) < itemCount {
      t = make([]bellatrix.Transaction, itemCount)
    } else {
      t = t[:itemCount]
    }
    var endOffset int
    for i := 0; i < itemCount; i++ {
      if i < itemCount-1 {
        endOffset = int(sszutils.ReadOffset(buf[(i+1)*4:(i+2)*4]))
      } else {
        endOffset = buflen
      }
      if endOffset < offset || endOffset > buflen {
        return t, sszutils.ErrOffset
      }
      if t[i], err = fn40(t[i], buf[offset:endOffset]); err != nil {
        return t, err
      }
      offset = endOffset
    }
    return t, err
  }
  fn42 := func(_ capella.WithdrawalIndex, buf []byte) (capella.WithdrawalIndex, error) { // capella.WithdrawalIndex
    var err error
    var t capella.WithdrawalIndex
    t = (capella.WithdrawalIndex)(sszutils.UnmarshallUint64(buf))
    return t, err
  }
  fn43 := func(t *capella.Withdrawal, buf []byte) (*capella.Withdrawal, error) { // *capella.Withdrawal
    var err error
    if t == nil {
      t = new(capella.Withdrawal)
    }
    bufpos := 0
    buflen := len(buf)
    minsize := 44
    if buflen < minsize {
      return t, sszutils.ErrUnexpectedEOF
    }
    // Field #0 'Index'
    {
      fieldsize := 8
      if t.Index, err = fn42(t.Index, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #1 'ValidatorIndex'
    {
      fieldsize := 8
      if t.ValidatorIndex, err = fn2(t.ValidatorIndex, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #2 'Address'
    {
      fieldsize := 20
      if t.Address, err = fn36(t.Address, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #3 'Amount'
    {
      fieldsize := 8
      if t.Amount, err = fn26(t.Amount, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    return t, err
  }
  fn44 := func(t []*capella.Withdrawal, buf []byte) ([]*capella.Withdrawal, error) { // []*capella.Withdrawal
    var err error
    buflen := len(buf)
    itemsize := 44
    itemCount := buflen / itemsize
    if buflen % itemsize != 0 {
      return t, sszutils.ErrUnexpectedEOF
    }
    if len(t) < itemCount {
      t = make([]*capella.Withdrawal, itemCount)
    } else {
      t = t[:itemCount]
    }
    for i := 0; i < itemCount; i++ {
      if t[i], err = fn43(t[i], buf[i*itemsize:(i+1)*itemsize]); err != nil {
        return t, err
      }
    }
    return t, err
  }
  fn45 := func(t *deneb.ExecutionPayload, buf []byte) (*deneb.ExecutionPayload, error) { // *deneb.ExecutionPayload
    var err error
    if t == nil {
      t = new(deneb.ExecutionPayload)
    }
    bufpos := 0
    buflen := len(buf)
    minsize := 528
    if buflen < minsize {
      return t, sszutils.ErrUnexpectedEOF
    }
    // Field #0 'ParentHash'
    {
      fieldsize := 32
      if t.ParentHash, err = fn35(t.ParentHash, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #1 'FeeRecipient'
    {
      fieldsize := 20
      if t.FeeRecipient, err = fn36(t.FeeRecipient, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #2 'StateRoot'
    {
      fieldsize := 32
      if t.StateRoot, err = fn3(t.StateRoot, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #3 'ReceiptsRoot'
    {
      fieldsize := 32
      if t.ReceiptsRoot, err = fn3(t.ReceiptsRoot, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #4 'LogsBloom'
    {
      fieldsize := 256
      if t.LogsBloom, err = fn37(t.LogsBloom, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #5 'PrevRandao'
    {
      fieldsize := 32
      if t.PrevRandao, err = fn8(t.PrevRandao, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #6 'BlockNumber'
    {
      fieldsize := 8
      if t.BlockNumber, err = fn5(t.BlockNumber, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #7 'GasLimit'
    {
      fieldsize := 8
      if t.GasLimit, err = fn5(t.GasLimit, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #8 'GasUsed'
    {
      fieldsize := 8
      if t.GasUsed, err = fn5(t.GasUsed, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #9 'Timestamp'
    {
      fieldsize := 8
      if t.Timestamp, err = fn5(t.Timestamp, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Offset #10 'ExtraData'
    offset10 := int(sszutils.ReadOffset(buf[bufpos:bufpos+4]))
    bufpos += 4
    // Field #11 'BaseFeePerGas'
    {
      fieldsize := 32
      if t.BaseFeePerGas, err = fn39(t.BaseFeePerGas, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #12 'BlockHash'
    {
      fieldsize := 32
      if t.BlockHash, err = fn35(t.BlockHash, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Offset #13 'Transactions'
    offset13 := int(sszutils.ReadOffset(buf[bufpos:bufpos+4]))
    bufpos += 4
    // Offset #14 'Withdrawals'
    offset14 := int(sszutils.ReadOffset(buf[bufpos:bufpos+4]))
    bufpos += 4
    // Field #15 'BlobGasUsed'
    {
      fieldsize := 8
      if t.BlobGasUsed, err = fn5(t.BlobGasUsed, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #16 'ExcessBlobGas'
    {
      fieldsize := 8
      if t.ExcessBlobGas, err = fn5(t.ExcessBlobGas, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Dynamic Field #10 'ExtraData'
    if offset10 < bufpos || offset13 > buflen || offset13 < offset10 {
      return t, sszutils.ErrOffset
    }
    {
      fieldSlice := buf[offset10:offset13]
      if t.ExtraData, err = fn38(t.ExtraData, fieldSlice); err != nil {
        return t, err
      }
      bufpos += len(fieldSlice)
    }
    // Dynamic Field #13 'Transactions'
    if offset13 < bufpos || offset14 > buflen || offset14 < offset13 {
      return t, sszutils.ErrOffset
    }
    {
      fieldSlice := buf[offset13:offset14]
      if t.Transactions, err = fn41(t.Transactions, fieldSlice); err != nil {
        return t, err
      }
      bufpos += len(fieldSlice)
    }
    // Dynamic Field #14 'Withdrawals'
    if offset14 < bufpos  {
      return t, sszutils.ErrOffset
    }
    {
      fieldSlice := buf[offset14:]
      if t.Withdrawals, err = fn44(t.Withdrawals, fieldSlice); err != nil {
        return t, err
      }
      bufpos += len(fieldSlice)
    }
    return t, err
  }
  fn46 := func(t *capella.BLSToExecutionChange, buf []byte) (*capella.BLSToExecutionChange, error) { // *capella.BLSToExecutionChange
    var err error
    if t == nil {
      t = new(capella.BLSToExecutionChange)
    }
    bufpos := 0
    buflen := len(buf)
    minsize := 76
    if buflen < minsize {
      return t, sszutils.ErrUnexpectedEOF
    }
    // Field #0 'ValidatorIndex'
    {
      fieldsize := 8
      if t.ValidatorIndex, err = fn2(t.ValidatorIndex, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #1 'FromBLSPubkey'
    {
      fieldsize := 48
      if t.FromBLSPubkey, err = fn25(t.FromBLSPubkey, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #2 'ToExecutionAddress'
    {
      fieldsize := 20
      if t.ToExecutionAddress, err = fn36(t.ToExecutionAddress, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    return t, err
  }
  fn47 := func(t *capella.SignedBLSToExecutionChange, buf []byte) (*capella.SignedBLSToExecutionChange, error) { // *capella.SignedBLSToExecutionChange
    var err error
    if t == nil {
      t = new(capella.SignedBLSToExecutionChange)
    }
    bufpos := 0
    buflen := len(buf)
    minsize := 172
    if buflen < minsize {
      return t, sszutils.ErrUnexpectedEOF
    }
    // Field #0 'Message'
    {
      fieldsize := 76
      if t.Message, err = fn46(t.Message, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #1 'Signature'
    {
      fieldsize := 96
      if t.Signature, err = fn4(t.Signature, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    return t, err
  }
  fn48 := func(t []*capella.SignedBLSToExecutionChange, buf []byte) ([]*capella.SignedBLSToExecutionChange, error) { // []*capella.SignedBLSToExecutionChange
    var err error
    buflen := len(buf)
    itemsize := 172
    itemCount := buflen / itemsize
    if buflen % itemsize != 0 {
      return t, sszutils.ErrUnexpectedEOF
    }
    if len(t) < itemCount {
      t = make([]*capella.SignedBLSToExecutionChange, itemCount)
    } else {
      t = t[:itemCount]
    }
    for i := 0; i < itemCount; i++ {
      if t[i], err = fn47(t[i], buf[i*itemsize:(i+1)*itemsize]); err != nil {
        return t, err
      }
    }
    return t, err
  }
  fn49 := func(t deneb.KZGCommitment, buf []byte) (deneb.KZGCommitment, error) { // deneb.KZGCommitment:48
    var err error
    itemsize := 1
    limit := 48
    if len(buf) > int(limit) * itemsize {
      return t, sszutils.ErrListTooBig
    }
    copy(t[:], buf[:])
    return t, err
  }
  fn50 := func(t []deneb.KZGCommitment, buf []byte) ([]deneb.KZGCommitment, error) { // []deneb.KZGCommitment:48
    var err error
    buflen := len(buf)
    itemsize := 48
    itemCount := buflen / itemsize
    if buflen % itemsize != 0 {
      return t, sszutils.ErrUnexpectedEOF
    }
    if len(t) < itemCount {
      t = make([]deneb.KZGCommitment, itemCount)
    } else {
      t = t[:itemCount]
    }
    for i := 0; i < itemCount; i++ {
      if t[i], err = fn49(t[i], buf[i*itemsize:(i+1)*itemsize]); err != nil {
        return t, err
      }
    }
    return t, err
  }
  fn51 := func(t *deneb.BeaconBlockBody, buf []byte) (*deneb.BeaconBlockBody, error) { // *deneb.BeaconBlockBody
    var err error
    if t == nil {
      t = new(deneb.BeaconBlockBody)
    }
    bufpos := 0
    buflen := len(buf)
    minsize := 232
    if buflen < minsize {
      return t, sszutils.ErrUnexpectedEOF
    }
    // Field #0 'RANDAOReveal'
    {
      fieldsize := 96
      if t.RANDAOReveal, err = fn4(t.RANDAOReveal, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #1 'ETH1Data'
    {
      fieldsize := 72
      if t.ETH1Data, err = fn7(t.ETH1Data, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #2 'Graffiti'
    {
      fieldsize := 32
      if t.Graffiti, err = fn8(t.Graffiti, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Offset #3 'ProposerSlashings'
    offset3 := int(sszutils.ReadOffset(buf[bufpos:bufpos+4]))
    bufpos += 4
    // Offset #4 'AttesterSlashings'
    offset4 := int(sszutils.ReadOffset(buf[bufpos:bufpos+4]))
    bufpos += 4
    // Offset #5 'Attestations'
    offset5 := int(sszutils.ReadOffset(buf[bufpos:bufpos+4]))
    bufpos += 4
    // Offset #6 'Deposits'
    offset6 := int(sszutils.ReadOffset(buf[bufpos:bufpos+4]))
    bufpos += 4
    // Offset #7 'VoluntaryExits'
    offset7 := int(sszutils.ReadOffset(buf[bufpos:bufpos+4]))
    bufpos += 4
    // Field #8 'SyncAggregate'
    {
      fieldsize := sfn4
      minsize += fieldsize
      if buflen < minsize {
        return t, sszutils.ErrUnexpectedEOF
      }
      if t.SyncAggregate, err = fn34(t.SyncAggregate, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Offset #9 'ExecutionPayload'
    offset9 := int(sszutils.ReadOffset(buf[bufpos:bufpos+4]))
    bufpos += 4
    // Offset #10 'BLSToExecutionChanges'
    offset10 := int(sszutils.ReadOffset(buf[bufpos:bufpos+4]))
    bufpos += 4
    // Offset #11 'BlobKZGCommitments'
    offset11 := int(sszutils.ReadOffset(buf[bufpos:bufpos+4]))
    bufpos += 4
    // Dynamic Field #3 'ProposerSlashings'
    if offset3 < bufpos || offset4 > buflen || offset4 < offset3 {
      return t, sszutils.ErrOffset
    }
    {
      fieldSlice := buf[offset3:offset4]
      if t.ProposerSlashings, err = fn12(t.ProposerSlashings, fieldSlice); err != nil {
        return t, err
      }
      bufpos += len(fieldSlice)
    }
    // Dynamic Field #4 'AttesterSlashings'
    if offset4 < bufpos || offset5 > buflen || offset5 < offset4 {
      return t, sszutils.ErrOffset
    }
    {
      fieldSlice := buf[offset4:offset5]
      if t.AttesterSlashings, err = fn20(t.AttesterSlashings, fieldSlice); err != nil {
        return t, err
      }
      bufpos += len(fieldSlice)
    }
    // Dynamic Field #5 'Attestations'
    if offset5 < bufpos || offset6 > buflen || offset6 < offset5 {
      return t, sszutils.ErrOffset
    }
    {
      fieldSlice := buf[offset5:offset6]
      if t.Attestations, err = fn23(t.Attestations, fieldSlice); err != nil {
        return t, err
      }
      bufpos += len(fieldSlice)
    }
    // Dynamic Field #6 'Deposits'
    if offset6 < bufpos || offset7 > buflen || offset7 < offset6 {
      return t, sszutils.ErrOffset
    }
    {
      fieldSlice := buf[offset6:offset7]
      if t.Deposits, err = fn29(t.Deposits, fieldSlice); err != nil {
        return t, err
      }
      bufpos += len(fieldSlice)
    }
    // Dynamic Field #7 'VoluntaryExits'
    if offset7 < bufpos || offset9 > buflen || offset9 < offset7 {
      return t, sszutils.ErrOffset
    }
    {
      fieldSlice := buf[offset7:offset9]
      if t.VoluntaryExits, err = fn32(t.VoluntaryExits, fieldSlice); err != nil {
        return t, err
      }
      bufpos += len(fieldSlice)
    }
    // Dynamic Field #9 'ExecutionPayload'
    if offset9 < bufpos || offset10 > buflen || offset10 < offset9 {
      return t, sszutils.ErrOffset
    }
    {
      fieldSlice := buf[offset9:offset10]
      if t.ExecutionPayload, err = fn45(t.ExecutionPayload, fieldSlice); err != nil {
        return t, err
      }
      bufpos += len(fieldSlice)
    }
    // Dynamic Field #10 'BLSToExecutionChanges'
    if offset10 < bufpos || offset11 > buflen || offset11 < offset10 {
      return t, sszutils.ErrOffset
    }
    {
      fieldSlice := buf[offset10:offset11]
      if t.BLSToExecutionChanges, err = fn48(t.BLSToExecutionChanges, fieldSlice); err != nil {
        return t, err
      }
      bufpos += len(fieldSlice)
    }
    // Dynamic Field #11 'BlobKZGCommitments'
    if offset11 < bufpos  {
      return t, sszutils.ErrOffset
    }
    {
      fieldSlice := buf[offset11:]
      if t.BlobKZGCommitments, err = fn50(t.BlobKZGCommitments, fieldSlice); err != nil {
        return t, err
      }
      bufpos += len(fieldSlice)
    }
    return t, err
  }
  fn52 := func(t *deneb.BeaconBlock, buf []byte) (*deneb.BeaconBlock, error) { // *deneb.BeaconBlock
    var err error
    if t == nil {
      t = new(deneb.BeaconBlock)
    }
    bufpos := 0
    buflen := len(buf)
    minsize := 84
    if buflen < minsize {
      return t, sszutils.ErrUnexpectedEOF
    }
    // Field #0 'Slot'
    {
      fieldsize := 8
      if t.Slot, err = fn1(t.Slot, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #1 'ProposerIndex'
    {
      fieldsize := 8
      if t.ProposerIndex, err = fn2(t.ProposerIndex, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #2 'ParentRoot'
    {
      fieldsize := 32
      if t.ParentRoot, err = fn3(t.ParentRoot, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #3 'StateRoot'
    {
      fieldsize := 32
      if t.StateRoot, err = fn3(t.StateRoot, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Offset #4 'Body'
    offset4 := int(sszutils.ReadOffset(buf[bufpos:bufpos+4]))
    bufpos += 4
    // Dynamic Field #4 'Body'
    if offset4 < bufpos  {
      return t, sszutils.ErrOffset
    }
    {
      fieldSlice := buf[offset4:]
      if t.Body, err = fn51(t.Body, fieldSlice); err != nil {
        return t, err
      }
      bufpos += len(fieldSlice)
    }
    return t, err
  }
  fn53 := func(t *TestBeaconBlock, buf []byte) (*TestBeaconBlock, error) { // *TestBeaconBlock
    var err error
    if t == nil {
      t = new(TestBeaconBlock)
    }
    bufpos := 0
    buflen := len(buf)
    minsize := 100
    if buflen < minsize {
      return t, sszutils.ErrUnexpectedEOF
    }
    // Offset #0 'Message'
    offset0 := int(sszutils.ReadOffset(buf[bufpos:bufpos+4]))
    bufpos += 4
    // Field #1 'Signature'
    {
      fieldsize := 96
      if t.Signature, err = fn4(t.Signature, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Dynamic Field #0 'Message'
    if offset0 < bufpos  {
      return t, sszutils.ErrOffset
    }
    {
      fieldSlice := buf[offset0:]
      if t.Message, err = fn52(t.Message, fieldSlice); err != nil {
        return t, err
      }
      bufpos += len(fieldSlice)
    }
    return t, err
  }
  _, err = fn53(t, buf)
  return err
}
func (t *TestBeaconBlock) UnmarshalSSZ(buf []byte) (err error) {
  return t.UnmarshalSSZDyn(dynssz.GetGlobalDynSsz(), buf)
}


