// Code generated by dynamic-ssz. DO NOT EDIT.
package main

import (
	"github.com/attestantio/go-eth2-client/spec/altair"
	"github.com/attestantio/go-eth2-client/spec/bellatrix"
	"github.com/attestantio/go-eth2-client/spec/capella"
	"github.com/attestantio/go-eth2-client/spec/deneb"
	"github.com/attestantio/go-eth2-client/spec/phase0"
	"github.com/holiman/uint256"
	dynssz "github.com/pk910/dynamic-ssz"
	"github.com/pk910/dynamic-ssz/sszutils"
	go_bitfield "github.com/prysmaticlabs/go-bitfield"
)
var _ = sszutils.ErrListTooBig


func (t *TestBeaconState) MarshalSSZDyn(ds *dynssz.DynSsz, buf []byte) (dst []byte, err error) {
  dst = buf
  fn1 := func(t uint64) (err error) { // uint64
    dst = sszutils.MarshalUint64(dst, uint64(t))
    return err
  }
  fn2 := func(t phase0.Root) (err error) { // phase0.Root:32
    dst = append(dst, t[:32]...)
    return err
  }
  fn3 := func(t phase0.Slot) (err error) { // phase0.Slot
    dst = sszutils.MarshalUint64(dst, uint64(t))
    return err
  }
  fn4 := func(t phase0.Version) (err error) { // phase0.Version:4
    dst = append(dst, t[:4]...)
    return err
  }
  fn5 := func(t phase0.Epoch) (err error) { // phase0.Epoch
    dst = sszutils.MarshalUint64(dst, uint64(t))
    return err
  }
  fn6 := func(t *phase0.Fork) (err error) { // *phase0.Fork
    // Field #0 'PreviousVersion'
    if err = fn4(t.PreviousVersion); err != nil {
      return err
    }
    // Field #1 'CurrentVersion'
    if err = fn4(t.CurrentVersion); err != nil {
      return err
    }
    // Field #2 'Epoch'
    if err = fn5(t.Epoch); err != nil {
      return err
    }
    return err
  }
  fn7 := func(t phase0.ValidatorIndex) (err error) { // phase0.ValidatorIndex
    dst = sszutils.MarshalUint64(dst, uint64(t))
    return err
  }
  fn8 := func(t *phase0.BeaconBlockHeader) (err error) { // *phase0.BeaconBlockHeader
    // Field #0 'Slot'
    if err = fn3(t.Slot); err != nil {
      return err
    }
    // Field #1 'ProposerIndex'
    if err = fn7(t.ProposerIndex); err != nil {
      return err
    }
    // Field #2 'ParentRoot'
    if err = fn2(t.ParentRoot); err != nil {
      return err
    }
    // Field #3 'StateRoot'
    if err = fn2(t.StateRoot); err != nil {
      return err
    }
    // Field #4 'BodyRoot'
    if err = fn2(t.BodyRoot); err != nil {
      return err
    }
    return err
  }
  fn9 := func(t []phase0.Root) (err error) { // []phase0.Root:8192:SLOTS_PER_HISTORICAL_ROOT:32
    hasLimit, limit, err := ds.ResolveSpecValue("SLOTS_PER_HISTORICAL_ROOT")
    if err != nil {
      return err
    }
    if !hasLimit {
      limit = 8192
    }
    vlen := len(t)
    if vlen > int(limit) {
      return sszutils.ErrListTooBig
    }
    for i := 0; i < vlen; i++ {
      if err = fn2(t[i]); err != nil {
        return err
      }
    }
    if vlen < int(limit) {
      dst = sszutils.AppendZeroPadding(dst, (int(limit) - vlen) * 32)
    }
    return err
  }
  fn10 := func(t []phase0.Root) (err error) { // []phase0.Root:32
    vlen := len(t)
    for i := 0; i < vlen; i++ {
      if err = fn2(t[i]); err != nil {
        return err
      }
    }
    return err
  }
  fn11 := func(t []byte) (err error) { // []byte:32
    limit := 32
    vlen := len(t)
    if vlen > int(limit) {
      return sszutils.ErrListTooBig
    }
    vlimit := int(limit)
    if vlimit > vlen {
      vlimit = vlen
    }
    dst = append(dst, t[:vlimit]...)
    if vlen < int(limit) {
      dst = sszutils.AppendZeroPadding(dst, int(limit) - vlen)
    }
    return err
  }
  fn12 := func(t *phase0.ETH1Data) (err error) { // *phase0.ETH1Data
    // Field #0 'DepositRoot'
    if err = fn2(t.DepositRoot); err != nil {
      return err
    }
    // Field #1 'DepositCount'
    if err = fn1(t.DepositCount); err != nil {
      return err
    }
    // Field #2 'BlockHash'
    if err = fn11(t.BlockHash); err != nil {
      return err
    }
    return err
  }
  fn13 := func(t []*phase0.ETH1Data) (err error) { // []*phase0.ETH1Data
    vlen := len(t)
    for i := 0; i < vlen; i++ {
      if err = fn12(t[i]); err != nil {
        return err
      }
    }
    return err
  }
  fn14 := func(t phase0.BLSPubKey) (err error) { // phase0.BLSPubKey:48
    dst = append(dst, t[:48]...)
    return err
  }
  fn15 := func(t phase0.Gwei) (err error) { // phase0.Gwei
    dst = sszutils.MarshalUint64(dst, uint64(t))
    return err
  }
  fn16 := func(t bool) (err error) { // bool
    dst = sszutils.MarshalBool(dst, t)
    return err
  }
  fn17 := func(t *phase0.Validator) (err error) { // *phase0.Validator
    // Field #0 'PublicKey'
    if err = fn14(t.PublicKey); err != nil {
      return err
    }
    // Field #1 'WithdrawalCredentials'
    if err = fn11(t.WithdrawalCredentials); err != nil {
      return err
    }
    // Field #2 'EffectiveBalance'
    if err = fn15(t.EffectiveBalance); err != nil {
      return err
    }
    // Field #3 'Slashed'
    if err = fn16(t.Slashed); err != nil {
      return err
    }
    // Field #4 'ActivationEligibilityEpoch'
    if err = fn5(t.ActivationEligibilityEpoch); err != nil {
      return err
    }
    // Field #5 'ActivationEpoch'
    if err = fn5(t.ActivationEpoch); err != nil {
      return err
    }
    // Field #6 'ExitEpoch'
    if err = fn5(t.ExitEpoch); err != nil {
      return err
    }
    // Field #7 'WithdrawableEpoch'
    if err = fn5(t.WithdrawableEpoch); err != nil {
      return err
    }
    return err
  }
  fn18 := func(t []*phase0.Validator) (err error) { // []*phase0.Validator
    vlen := len(t)
    for i := 0; i < vlen; i++ {
      if err = fn17(t[i]); err != nil {
        return err
      }
    }
    return err
  }
  fn19 := func(t []phase0.Gwei) (err error) { // []phase0.Gwei
    vlen := len(t)
    for i := 0; i < vlen; i++ {
      if err = fn15(t[i]); err != nil {
        return err
      }
    }
    return err
  }
  fn20 := func(t []phase0.Root) (err error) { // []phase0.Root:65536:EPOCHS_PER_HISTORICAL_VECTOR:32
    hasLimit, limit, err := ds.ResolveSpecValue("EPOCHS_PER_HISTORICAL_VECTOR")
    if err != nil {
      return err
    }
    if !hasLimit {
      limit = 65536
    }
    vlen := len(t)
    if vlen > int(limit) {
      return sszutils.ErrListTooBig
    }
    for i := 0; i < vlen; i++ {
      if err = fn2(t[i]); err != nil {
        return err
      }
    }
    if vlen < int(limit) {
      dst = sszutils.AppendZeroPadding(dst, (int(limit) - vlen) * 32)
    }
    return err
  }
  fn21 := func(t []phase0.Gwei) (err error) { // []phase0.Gwei:8192:EPOCHS_PER_SLASHINGS_VECTOR
    hasLimit, limit, err := ds.ResolveSpecValue("EPOCHS_PER_SLASHINGS_VECTOR")
    if err != nil {
      return err
    }
    if !hasLimit {
      limit = 8192
    }
    vlen := len(t)
    if vlen > int(limit) {
      return sszutils.ErrListTooBig
    }
    for i := 0; i < vlen; i++ {
      if err = fn15(t[i]); err != nil {
        return err
      }
    }
    if vlen < int(limit) {
      dst = sszutils.AppendZeroPadding(dst, (int(limit) - vlen) * 8)
    }
    return err
  }
  fn22 := func(t altair.ParticipationFlags) (err error) { // altair.ParticipationFlags
    dst = sszutils.MarshalUint8(dst, uint8(t))
    return err
  }
  fn23 := func(t []altair.ParticipationFlags) (err error) { // []altair.ParticipationFlags
    vlen := len(t)
    for i := 0; i < vlen; i++ {
      if err = fn22(t[i]); err != nil {
        return err
      }
    }
    return err
  }
  fn24 := func(t go_bitfield.Bitvector4) (err error) { // go_bitfield.Bitvector4:1
    limit := 1
    vlen := len(t)
    if vlen > int(limit) {
      return sszutils.ErrListTooBig
    }
    vlimit := int(limit)
    if vlimit > vlen {
      vlimit = vlen
    }
    dst = append(dst, t[:vlimit]...)
    if vlen < int(limit) {
      dst = sszutils.AppendZeroPadding(dst, int(limit) - vlen)
    }
    return err
  }
  fn25 := func(t *phase0.Checkpoint) (err error) { // *phase0.Checkpoint
    // Field #0 'Epoch'
    if err = fn5(t.Epoch); err != nil {
      return err
    }
    // Field #1 'Root'
    if err = fn2(t.Root); err != nil {
      return err
    }
    return err
  }
  fn26 := func(t []uint64) (err error) { // []uint64
    vlen := len(t)
    for i := 0; i < vlen; i++ {
      if err = fn1(t[i]); err != nil {
        return err
      }
    }
    return err
  }
  fn27 := func(t []phase0.BLSPubKey) (err error) { // []phase0.BLSPubKey:512:SYNC_COMMITTEE_SIZE:48
    hasLimit, limit, err := ds.ResolveSpecValue("SYNC_COMMITTEE_SIZE")
    if err != nil {
      return err
    }
    if !hasLimit {
      limit = 512
    }
    vlen := len(t)
    if vlen > int(limit) {
      return sszutils.ErrListTooBig
    }
    for i := 0; i < vlen; i++ {
      if err = fn14(t[i]); err != nil {
        return err
      }
    }
    if vlen < int(limit) {
      dst = sszutils.AppendZeroPadding(dst, (int(limit) - vlen) * 48)
    }
    return err
  }
  fn28 := func(t *altair.SyncCommittee) (err error) { // *altair.SyncCommittee
    // Field #0 'Pubkeys'
    if err = fn27(t.Pubkeys); err != nil {
      return err
    }
    // Field #1 'AggregatePubkey'
    if err = fn14(t.AggregatePubkey); err != nil {
      return err
    }
    return err
  }
  fn29 := func(t phase0.Hash32) (err error) { // phase0.Hash32:32
    dst = append(dst, t[:32]...)
    return err
  }
  fn30 := func(t bellatrix.ExecutionAddress) (err error) { // bellatrix.ExecutionAddress:20
    dst = append(dst, t[:20]...)
    return err
  }
  fn31 := func(t [256]byte) (err error) { // [256]byte:256
    dst = append(dst, t[:256]...)
    return err
  }
  fn32 := func(t [32]byte) (err error) { // [32]byte:32
    dst = append(dst, t[:32]...)
    return err
  }
  fn33 := func(t []byte) (err error) { // []byte
    dst = append(dst, t[:]...)
    return err
  }
  fn34 := func(t *uint256.Int) (err error) { // *uint256.Int:4
    vlen := len(t)
    for i := 0; i < vlen; i++ {
      if err = fn1(t[i]); err != nil {
        return err
      }
    }
    return err
  }
  fn35 := func(t *deneb.ExecutionPayloadHeader) (err error) { // *deneb.ExecutionPayloadHeader
    dstlen := len(dst)
    // Field #0 'ParentHash'
    if err = fn29(t.ParentHash); err != nil {
      return err
    }
    // Field #1 'FeeRecipient'
    if err = fn30(t.FeeRecipient); err != nil {
      return err
    }
    // Field #2 'StateRoot'
    if err = fn2(t.StateRoot); err != nil {
      return err
    }
    // Field #3 'ReceiptsRoot'
    if err = fn2(t.ReceiptsRoot); err != nil {
      return err
    }
    // Field #4 'LogsBloom'
    if err = fn31(t.LogsBloom); err != nil {
      return err
    }
    // Field #5 'PrevRandao'
    if err = fn32(t.PrevRandao); err != nil {
      return err
    }
    // Field #6 'BlockNumber'
    if err = fn1(t.BlockNumber); err != nil {
      return err
    }
    // Field #7 'GasLimit'
    if err = fn1(t.GasLimit); err != nil {
      return err
    }
    // Field #8 'GasUsed'
    if err = fn1(t.GasUsed); err != nil {
      return err
    }
    // Field #9 'Timestamp'
    if err = fn1(t.Timestamp); err != nil {
      return err
    }
    // Offset #10 'ExtraData'
    offset10 := len(dst)
    dst = sszutils.MarshalOffset(dst, 0)
    // Field #11 'BaseFeePerGas'
    if err = fn34(t.BaseFeePerGas); err != nil {
      return err
    }
    // Field #12 'BlockHash'
    if err = fn29(t.BlockHash); err != nil {
      return err
    }
    // Field #13 'TransactionsRoot'
    if err = fn2(t.TransactionsRoot); err != nil {
      return err
    }
    // Field #14 'WithdrawalsRoot'
    if err = fn2(t.WithdrawalsRoot); err != nil {
      return err
    }
    // Field #15 'BlobGasUsed'
    if err = fn1(t.BlobGasUsed); err != nil {
      return err
    }
    // Field #16 'ExcessBlobGas'
    if err = fn1(t.ExcessBlobGas); err != nil {
      return err
    }
    // Dynamic Field #10 'ExtraData'
    sszutils.UpdateOffset(dst[offset10:offset10+4], len(dst)-dstlen)
    if err = fn33(t.ExtraData); err != nil {
      return err
    }
    return err
  }
  fn36 := func(t capella.WithdrawalIndex) (err error) { // capella.WithdrawalIndex
    dst = sszutils.MarshalUint64(dst, uint64(t))
    return err
  }
  fn37 := func(t *capella.HistoricalSummary) (err error) { // *capella.HistoricalSummary
    // Field #0 'BlockSummaryRoot'
    if err = fn2(t.BlockSummaryRoot); err != nil {
      return err
    }
    // Field #1 'StateSummaryRoot'
    if err = fn2(t.StateSummaryRoot); err != nil {
      return err
    }
    return err
  }
  fn38 := func(t []*capella.HistoricalSummary) (err error) { // []*capella.HistoricalSummary
    vlen := len(t)
    for i := 0; i < vlen; i++ {
      if err = fn37(t[i]); err != nil {
        return err
      }
    }
    return err
  }
  fn39 := func(t *TestBeaconState) (err error) { // *TestBeaconState
    dstlen := len(dst)
    // Field #0 'GenesisTime'
    if err = fn1(t.GenesisTime); err != nil {
      return err
    }
    // Field #1 'GenesisValidatorsRoot'
    if err = fn2(t.GenesisValidatorsRoot); err != nil {
      return err
    }
    // Field #2 'Slot'
    if err = fn3(t.Slot); err != nil {
      return err
    }
    // Field #3 'Fork'
    if err = fn6(t.Fork); err != nil {
      return err
    }
    // Field #4 'LatestBlockHeader'
    if err = fn8(t.LatestBlockHeader); err != nil {
      return err
    }
    // Field #5 'BlockRoots'
    if err = fn9(t.BlockRoots); err != nil {
      return err
    }
    // Field #6 'StateRoots'
    if err = fn9(t.StateRoots); err != nil {
      return err
    }
    // Offset #7 'HistoricalRoots'
    offset7 := len(dst)
    dst = sszutils.MarshalOffset(dst, 0)
    // Field #8 'ETH1Data'
    if err = fn12(t.ETH1Data); err != nil {
      return err
    }
    // Offset #9 'ETH1DataVotes'
    offset9 := len(dst)
    dst = sszutils.MarshalOffset(dst, 0)
    // Field #10 'ETH1DepositIndex'
    if err = fn1(t.ETH1DepositIndex); err != nil {
      return err
    }
    // Offset #11 'Validators'
    offset11 := len(dst)
    dst = sszutils.MarshalOffset(dst, 0)
    // Offset #12 'Balances'
    offset12 := len(dst)
    dst = sszutils.MarshalOffset(dst, 0)
    // Field #13 'RANDAOMixes'
    if err = fn20(t.RANDAOMixes); err != nil {
      return err
    }
    // Field #14 'Slashings'
    if err = fn21(t.Slashings); err != nil {
      return err
    }
    // Offset #15 'PreviousEpochParticipation'
    offset15 := len(dst)
    dst = sszutils.MarshalOffset(dst, 0)
    // Offset #16 'CurrentEpochParticipation'
    offset16 := len(dst)
    dst = sszutils.MarshalOffset(dst, 0)
    // Field #17 'JustificationBits'
    if err = fn24(t.JustificationBits); err != nil {
      return err
    }
    // Field #18 'PreviousJustifiedCheckpoint'
    if err = fn25(t.PreviousJustifiedCheckpoint); err != nil {
      return err
    }
    // Field #19 'CurrentJustifiedCheckpoint'
    if err = fn25(t.CurrentJustifiedCheckpoint); err != nil {
      return err
    }
    // Field #20 'FinalizedCheckpoint'
    if err = fn25(t.FinalizedCheckpoint); err != nil {
      return err
    }
    // Offset #21 'InactivityScores'
    offset21 := len(dst)
    dst = sszutils.MarshalOffset(dst, 0)
    // Field #22 'CurrentSyncCommittee'
    if err = fn28(t.CurrentSyncCommittee); err != nil {
      return err
    }
    // Field #23 'NextSyncCommittee'
    if err = fn28(t.NextSyncCommittee); err != nil {
      return err
    }
    // Offset #24 'LatestExecutionPayloadHeader'
    offset24 := len(dst)
    dst = sszutils.MarshalOffset(dst, 0)
    // Field #25 'NextWithdrawalIndex'
    if err = fn36(t.NextWithdrawalIndex); err != nil {
      return err
    }
    // Field #26 'NextWithdrawalValidatorIndex'
    if err = fn7(t.NextWithdrawalValidatorIndex); err != nil {
      return err
    }
    // Offset #27 'HistoricalSummaries'
    offset27 := len(dst)
    dst = sszutils.MarshalOffset(dst, 0)
    // Dynamic Field #7 'HistoricalRoots'
    sszutils.UpdateOffset(dst[offset7:offset7+4], len(dst)-dstlen)
    if err = fn10(t.HistoricalRoots); err != nil {
      return err
    }
    // Dynamic Field #9 'ETH1DataVotes'
    sszutils.UpdateOffset(dst[offset9:offset9+4], len(dst)-dstlen)
    if err = fn13(t.ETH1DataVotes); err != nil {
      return err
    }
    // Dynamic Field #11 'Validators'
    sszutils.UpdateOffset(dst[offset11:offset11+4], len(dst)-dstlen)
    if err = fn18(t.Validators); err != nil {
      return err
    }
    // Dynamic Field #12 'Balances'
    sszutils.UpdateOffset(dst[offset12:offset12+4], len(dst)-dstlen)
    if err = fn19(t.Balances); err != nil {
      return err
    }
    // Dynamic Field #15 'PreviousEpochParticipation'
    sszutils.UpdateOffset(dst[offset15:offset15+4], len(dst)-dstlen)
    if err = fn23(t.PreviousEpochParticipation); err != nil {
      return err
    }
    // Dynamic Field #16 'CurrentEpochParticipation'
    sszutils.UpdateOffset(dst[offset16:offset16+4], len(dst)-dstlen)
    if err = fn23(t.CurrentEpochParticipation); err != nil {
      return err
    }
    // Dynamic Field #21 'InactivityScores'
    sszutils.UpdateOffset(dst[offset21:offset21+4], len(dst)-dstlen)
    if err = fn26(t.InactivityScores); err != nil {
      return err
    }
    // Dynamic Field #24 'LatestExecutionPayloadHeader'
    sszutils.UpdateOffset(dst[offset24:offset24+4], len(dst)-dstlen)
    if err = fn35(t.LatestExecutionPayloadHeader); err != nil {
      return err
    }
    // Dynamic Field #27 'HistoricalSummaries'
    sszutils.UpdateOffset(dst[offset27:offset27+4], len(dst)-dstlen)
    if err = fn38(t.HistoricalSummaries); err != nil {
      return err
    }
    return err
  }
  err = fn39(t)
  return dst, err
}
func (t *TestBeaconState) MarshalSSZ() ([]byte, error) {
  return dynssz.GetGlobalDynSsz().MarshalSSZ(t)
}
func (t *TestBeaconState) MarshalSSZTo(buf []byte) (dst []byte, err error) {
  return t.MarshalSSZDyn(dynssz.GetGlobalDynSsz(), buf)
}


func (t *TestBeaconState) SizeSSZDyn(ds *dynssz.DynSsz) (size int) {
  sfn1 := func(t []phase0.Root) (size int) { // []phase0.Root:8192:SLOTS_PER_HISTORICAL_ROOT:32
    hasLimit, limit, _ := ds.ResolveSpecValue("SLOTS_PER_HISTORICAL_ROOT")
    if !hasLimit {
      limit = 8192
    }
    size += int(limit) * 32
    return size
  }
  sfn2 := func(t []phase0.Root) (size int) { // []phase0.Root:32
    size += len(t) * 32
    return size
  }
  sfn3 := func(t []*phase0.ETH1Data) (size int) { // []*phase0.ETH1Data
    size += len(t) * 72
    return size
  }
  sfn4 := func(t []*phase0.Validator) (size int) { // []*phase0.Validator
    size += len(t) * 121
    return size
  }
  sfn5 := func(t []phase0.Gwei) (size int) { // []phase0.Gwei
    size += len(t) * 8
    return size
  }
  sfn6 := func(t []phase0.Root) (size int) { // []phase0.Root:65536:EPOCHS_PER_HISTORICAL_VECTOR:32
    hasLimit, limit, _ := ds.ResolveSpecValue("EPOCHS_PER_HISTORICAL_VECTOR")
    if !hasLimit {
      limit = 65536
    }
    size += int(limit) * 32
    return size
  }
  sfn7 := func(t []phase0.Gwei) (size int) { // []phase0.Gwei:8192:EPOCHS_PER_SLASHINGS_VECTOR
    hasLimit, limit, _ := ds.ResolveSpecValue("EPOCHS_PER_SLASHINGS_VECTOR")
    if !hasLimit {
      limit = 8192
    }
    size += int(limit) * 8
    return size
  }
  sfn8 := func(t []altair.ParticipationFlags) (size int) { // []altair.ParticipationFlags
    size += len(t) * 1
    return size
  }
  sfn9 := func(t []uint64) (size int) { // []uint64
    size += len(t) * 8
    return size
  }
  sfn10 := func(t []phase0.BLSPubKey) (size int) { // []phase0.BLSPubKey:512:SYNC_COMMITTEE_SIZE:48
    hasLimit, limit, _ := ds.ResolveSpecValue("SYNC_COMMITTEE_SIZE")
    if !hasLimit {
      limit = 512
    }
    size += int(limit) * 48
    return size
  }
  sfn11 := func(t *altair.SyncCommittee) (size int) { // *altair.SyncCommittee
    size = 48
    size += sfn10(t.Pubkeys)
    return size
  }
  sfn12 := func(t []byte) (size int) { // []byte
    size += len(t)
    return size
  }
  sfn13 := func(t *deneb.ExecutionPayloadHeader) (size int) { // *deneb.ExecutionPayloadHeader
    size = 580
    size += 4 + sfn12(t.ExtraData)
    return size
  }
  sfn14 := func(t []*capella.HistoricalSummary) (size int) { // []*capella.HistoricalSummary
    size += len(t) * 64
    return size
  }
  sfn15 := func(t *TestBeaconState) (size int) { // *TestBeaconState
    size = 393
    size += sfn1(t.BlockRoots)
    size += sfn1(t.StateRoots)
    size += 4 + sfn2(t.HistoricalRoots)
    size += 4 + sfn3(t.ETH1DataVotes)
    size += 4 + sfn4(t.Validators)
    size += 4 + sfn5(t.Balances)
    size += sfn6(t.RANDAOMixes)
    size += sfn7(t.Slashings)
    size += 4 + sfn8(t.PreviousEpochParticipation)
    size += 4 + sfn8(t.CurrentEpochParticipation)
    size += 4 + sfn9(t.InactivityScores)
    size += sfn11(t.CurrentSyncCommittee)
    size += sfn11(t.NextSyncCommittee)
    size += 4 + sfn13(t.LatestExecutionPayloadHeader)
    size += 4 + sfn14(t.HistoricalSummaries)
    return size
  }
  return sfn15(t)
}
func (t *TestBeaconState) SizeSSZ() (size int) {
  return t.SizeSSZDyn(dynssz.GetGlobalDynSsz())
}


func (t *TestBeaconState) UnmarshalSSZDyn(ds *dynssz.DynSsz, buf []byte) (err error) {
  sfn1 := func() (size int) { // []phase0.Root:8192:SLOTS_PER_HISTORICAL_ROOT:32
    hasLimit, limit, _ := ds.ResolveSpecValue("SLOTS_PER_HISTORICAL_ROOT")
    if !hasLimit {
      limit = 8192
    }
    size += int(limit) * 32
    return size
  }()
  sfn2 := func() (size int) { // []phase0.Root:65536:EPOCHS_PER_HISTORICAL_VECTOR:32
    hasLimit, limit, _ := ds.ResolveSpecValue("EPOCHS_PER_HISTORICAL_VECTOR")
    if !hasLimit {
      limit = 65536
    }
    size += int(limit) * 32
    return size
  }()
  sfn3 := func() (size int) { // []phase0.Gwei:8192:EPOCHS_PER_SLASHINGS_VECTOR
    hasLimit, limit, _ := ds.ResolveSpecValue("EPOCHS_PER_SLASHINGS_VECTOR")
    if !hasLimit {
      limit = 8192
    }
    size += int(limit) * 8
    return size
  }()
  sfn4 := func() (size int) { // []phase0.BLSPubKey:512:SYNC_COMMITTEE_SIZE:48
    hasLimit, limit, _ := ds.ResolveSpecValue("SYNC_COMMITTEE_SIZE")
    if !hasLimit {
      limit = 512
    }
    size += int(limit) * 48
    return size
  }()
  sfn5 := func() (size int) { // *altair.SyncCommittee
    size = 48
    size += sfn4
    return size
  }()
  fn1 := func(_ uint64, buf []byte) (uint64, error) { // uint64
    var err error
    var t uint64
    t = (uint64)(sszutils.UnmarshallUint64(buf))
    return t, err
  }
  fn2 := func(t phase0.Root, buf []byte) (phase0.Root, error) { // phase0.Root:32
    var err error
    itemsize := 1
    limit := 32
    if len(buf) > int(limit) * itemsize {
      return t, sszutils.ErrListTooBig
    }
    copy(t[:], buf[:])
    return t, err
  }
  fn3 := func(_ phase0.Slot, buf []byte) (phase0.Slot, error) { // phase0.Slot
    var err error
    var t phase0.Slot
    t = (phase0.Slot)(sszutils.UnmarshallUint64(buf))
    return t, err
  }
  fn4 := func(t phase0.Version, buf []byte) (phase0.Version, error) { // phase0.Version:4
    var err error
    itemsize := 1
    limit := 4
    if len(buf) > int(limit) * itemsize {
      return t, sszutils.ErrListTooBig
    }
    copy(t[:], buf[:])
    return t, err
  }
  fn5 := func(_ phase0.Epoch, buf []byte) (phase0.Epoch, error) { // phase0.Epoch
    var err error
    var t phase0.Epoch
    t = (phase0.Epoch)(sszutils.UnmarshallUint64(buf))
    return t, err
  }
  fn6 := func(t *phase0.Fork, buf []byte) (*phase0.Fork, error) { // *phase0.Fork
    var err error
    if t == nil {
      t = new(phase0.Fork)
    }
    bufpos := 0
    buflen := len(buf)
    minsize := 16
    if buflen < minsize {
      return t, sszutils.ErrUnexpectedEOF
    }
    // Field #0 'PreviousVersion'
    {
      fieldsize := 4
      if t.PreviousVersion, err = fn4(t.PreviousVersion, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #1 'CurrentVersion'
    {
      fieldsize := 4
      if t.CurrentVersion, err = fn4(t.CurrentVersion, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #2 'Epoch'
    {
      fieldsize := 8
      if t.Epoch, err = fn5(t.Epoch, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    return t, err
  }
  fn7 := func(_ phase0.ValidatorIndex, buf []byte) (phase0.ValidatorIndex, error) { // phase0.ValidatorIndex
    var err error
    var t phase0.ValidatorIndex
    t = (phase0.ValidatorIndex)(sszutils.UnmarshallUint64(buf))
    return t, err
  }
  fn8 := func(t *phase0.BeaconBlockHeader, buf []byte) (*phase0.BeaconBlockHeader, error) { // *phase0.BeaconBlockHeader
    var err error
    if t == nil {
      t = new(phase0.BeaconBlockHeader)
    }
    bufpos := 0
    buflen := len(buf)
    minsize := 112
    if buflen < minsize {
      return t, sszutils.ErrUnexpectedEOF
    }
    // Field #0 'Slot'
    {
      fieldsize := 8
      if t.Slot, err = fn3(t.Slot, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #1 'ProposerIndex'
    {
      fieldsize := 8
      if t.ProposerIndex, err = fn7(t.ProposerIndex, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #2 'ParentRoot'
    {
      fieldsize := 32
      if t.ParentRoot, err = fn2(t.ParentRoot, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #3 'StateRoot'
    {
      fieldsize := 32
      if t.StateRoot, err = fn2(t.StateRoot, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #4 'BodyRoot'
    {
      fieldsize := 32
      if t.BodyRoot, err = fn2(t.BodyRoot, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    return t, err
  }
  fn9 := func(t []phase0.Root, buf []byte) ([]phase0.Root, error) { // []phase0.Root:8192:SLOTS_PER_HISTORICAL_ROOT:32
    var err error
    itemsize := 32
    limit := sfn1 / itemsize
    if len(t) < int(limit) {
      t = make([]phase0.Root, int(limit))
    } else {
      t = t[:int(limit)]
    }
    if len(buf) > int(limit) * itemsize {
      return t, sszutils.ErrListTooBig
    }
    for i := 0; i < int(limit); i++ {
      if t[i], err = fn2(t[i], buf[i*itemsize:(i+1)*itemsize]); err != nil {
        return t, err
      }
    }
    return t, err
  }
  fn10 := func(t []phase0.Root, buf []byte) ([]phase0.Root, error) { // []phase0.Root:32
    var err error
    buflen := len(buf)
    itemsize := 32
    itemCount := buflen / itemsize
    if buflen % itemsize != 0 {
      return t, sszutils.ErrUnexpectedEOF
    }
    if len(t) < itemCount {
      t = make([]phase0.Root, itemCount)
    } else {
      t = t[:itemCount]
    }
    for i := 0; i < itemCount; i++ {
      if t[i], err = fn2(t[i], buf[i*itemsize:(i+1)*itemsize]); err != nil {
        return t, err
      }
    }
    return t, err
  }
  fn11 := func(t []byte, buf []byte) ([]byte, error) { // []byte:32
    var err error
    itemsize := 1
    limit := 32
    if len(t) < int(limit) {
      t = make([]byte, int(limit))
    } else {
      t = t[:int(limit)]
    }
    if len(buf) > int(limit) * itemsize {
      return t, sszutils.ErrListTooBig
    }
    copy(t[:], buf[:])
    return t, err
  }
  fn12 := func(t *phase0.ETH1Data, buf []byte) (*phase0.ETH1Data, error) { // *phase0.ETH1Data
    var err error
    if t == nil {
      t = new(phase0.ETH1Data)
    }
    bufpos := 0
    buflen := len(buf)
    minsize := 72
    if buflen < minsize {
      return t, sszutils.ErrUnexpectedEOF
    }
    // Field #0 'DepositRoot'
    {
      fieldsize := 32
      if t.DepositRoot, err = fn2(t.DepositRoot, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #1 'DepositCount'
    {
      fieldsize := 8
      if t.DepositCount, err = fn1(t.DepositCount, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #2 'BlockHash'
    {
      fieldsize := 32
      if t.BlockHash, err = fn11(t.BlockHash, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    return t, err
  }
  fn13 := func(t []*phase0.ETH1Data, buf []byte) ([]*phase0.ETH1Data, error) { // []*phase0.ETH1Data
    var err error
    buflen := len(buf)
    itemsize := 72
    itemCount := buflen / itemsize
    if buflen % itemsize != 0 {
      return t, sszutils.ErrUnexpectedEOF
    }
    if len(t) < itemCount {
      t = make([]*phase0.ETH1Data, itemCount)
    } else {
      t = t[:itemCount]
    }
    for i := 0; i < itemCount; i++ {
      if t[i], err = fn12(t[i], buf[i*itemsize:(i+1)*itemsize]); err != nil {
        return t, err
      }
    }
    return t, err
  }
  fn14 := func(t phase0.BLSPubKey, buf []byte) (phase0.BLSPubKey, error) { // phase0.BLSPubKey:48
    var err error
    itemsize := 1
    limit := 48
    if len(buf) > int(limit) * itemsize {
      return t, sszutils.ErrListTooBig
    }
    copy(t[:], buf[:])
    return t, err
  }
  fn15 := func(_ phase0.Gwei, buf []byte) (phase0.Gwei, error) { // phase0.Gwei
    var err error
    var t phase0.Gwei
    t = (phase0.Gwei)(sszutils.UnmarshallUint64(buf))
    return t, err
  }
  fn16 := func(_ bool, buf []byte) (bool, error) { // bool
    var err error
    var t bool
    t = (bool)(sszutils.UnmarshalBool(buf))
    return t, err
  }
  fn17 := func(t *phase0.Validator, buf []byte) (*phase0.Validator, error) { // *phase0.Validator
    var err error
    if t == nil {
      t = new(phase0.Validator)
    }
    bufpos := 0
    buflen := len(buf)
    minsize := 121
    if buflen < minsize {
      return t, sszutils.ErrUnexpectedEOF
    }
    // Field #0 'PublicKey'
    {
      fieldsize := 48
      if t.PublicKey, err = fn14(t.PublicKey, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #1 'WithdrawalCredentials'
    {
      fieldsize := 32
      if t.WithdrawalCredentials, err = fn11(t.WithdrawalCredentials, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #2 'EffectiveBalance'
    {
      fieldsize := 8
      if t.EffectiveBalance, err = fn15(t.EffectiveBalance, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #3 'Slashed'
    {
      fieldsize := 1
      if t.Slashed, err = fn16(t.Slashed, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #4 'ActivationEligibilityEpoch'
    {
      fieldsize := 8
      if t.ActivationEligibilityEpoch, err = fn5(t.ActivationEligibilityEpoch, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #5 'ActivationEpoch'
    {
      fieldsize := 8
      if t.ActivationEpoch, err = fn5(t.ActivationEpoch, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #6 'ExitEpoch'
    {
      fieldsize := 8
      if t.ExitEpoch, err = fn5(t.ExitEpoch, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #7 'WithdrawableEpoch'
    {
      fieldsize := 8
      if t.WithdrawableEpoch, err = fn5(t.WithdrawableEpoch, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    return t, err
  }
  fn18 := func(t []*phase0.Validator, buf []byte) ([]*phase0.Validator, error) { // []*phase0.Validator
    var err error
    buflen := len(buf)
    itemsize := 121
    itemCount := buflen / itemsize
    if buflen % itemsize != 0 {
      return t, sszutils.ErrUnexpectedEOF
    }
    if len(t) < itemCount {
      t = make([]*phase0.Validator, itemCount)
    } else {
      t = t[:itemCount]
    }
    for i := 0; i < itemCount; i++ {
      if t[i], err = fn17(t[i], buf[i*itemsize:(i+1)*itemsize]); err != nil {
        return t, err
      }
    }
    return t, err
  }
  fn19 := func(t []phase0.Gwei, buf []byte) ([]phase0.Gwei, error) { // []phase0.Gwei
    var err error
    buflen := len(buf)
    itemsize := 8
    itemCount := buflen / itemsize
    if buflen % itemsize != 0 {
      return t, sszutils.ErrUnexpectedEOF
    }
    if len(t) < itemCount {
      t = make([]phase0.Gwei, itemCount)
    } else {
      t = t[:itemCount]
    }
    for i := 0; i < itemCount; i++ {
      if t[i], err = fn15(t[i], buf[i*itemsize:(i+1)*itemsize]); err != nil {
        return t, err
      }
    }
    return t, err
  }
  fn20 := func(t []phase0.Root, buf []byte) ([]phase0.Root, error) { // []phase0.Root:65536:EPOCHS_PER_HISTORICAL_VECTOR:32
    var err error
    itemsize := 32
    limit := sfn2 / itemsize
    if len(t) < int(limit) {
      t = make([]phase0.Root, int(limit))
    } else {
      t = t[:int(limit)]
    }
    if len(buf) > int(limit) * itemsize {
      return t, sszutils.ErrListTooBig
    }
    for i := 0; i < int(limit); i++ {
      if t[i], err = fn2(t[i], buf[i*itemsize:(i+1)*itemsize]); err != nil {
        return t, err
      }
    }
    return t, err
  }
  fn21 := func(t []phase0.Gwei, buf []byte) ([]phase0.Gwei, error) { // []phase0.Gwei:8192:EPOCHS_PER_SLASHINGS_VECTOR
    var err error
    itemsize := 8
    limit := sfn3 / itemsize
    if len(t) < int(limit) {
      t = make([]phase0.Gwei, int(limit))
    } else {
      t = t[:int(limit)]
    }
    if len(buf) > int(limit) * itemsize {
      return t, sszutils.ErrListTooBig
    }
    for i := 0; i < int(limit); i++ {
      if t[i], err = fn15(t[i], buf[i*itemsize:(i+1)*itemsize]); err != nil {
        return t, err
      }
    }
    return t, err
  }
  fn22 := func(_ altair.ParticipationFlags, buf []byte) (altair.ParticipationFlags, error) { // altair.ParticipationFlags
    var err error
    var t altair.ParticipationFlags
    t = (altair.ParticipationFlags)(sszutils.UnmarshallUint8(buf))
    return t, err
  }
  fn23 := func(t []altair.ParticipationFlags, buf []byte) ([]altair.ParticipationFlags, error) { // []altair.ParticipationFlags
    var err error
    buflen := len(buf)
    itemsize := 1
    itemCount := buflen / itemsize
    if buflen % itemsize != 0 {
      return t, sszutils.ErrUnexpectedEOF
    }
    if len(t) < itemCount {
      t = make([]altair.ParticipationFlags, itemCount)
    } else {
      t = t[:itemCount]
    }
    for i := 0; i < itemCount; i++ {
      if t[i], err = fn22(t[i], buf[i*itemsize:(i+1)*itemsize]); err != nil {
        return t, err
      }
    }
    return t, err
  }
  fn24 := func(t go_bitfield.Bitvector4, buf []byte) (go_bitfield.Bitvector4, error) { // go_bitfield.Bitvector4:1
    var err error
    itemsize := 1
    limit := 1
    if len(t) < int(limit) {
      t = make(go_bitfield.Bitvector4, int(limit))
    } else {
      t = t[:int(limit)]
    }
    if len(buf) > int(limit) * itemsize {
      return t, sszutils.ErrListTooBig
    }
    copy(t[:], buf[:])
    return t, err
  }
  fn25 := func(t *phase0.Checkpoint, buf []byte) (*phase0.Checkpoint, error) { // *phase0.Checkpoint
    var err error
    if t == nil {
      t = new(phase0.Checkpoint)
    }
    bufpos := 0
    buflen := len(buf)
    minsize := 40
    if buflen < minsize {
      return t, sszutils.ErrUnexpectedEOF
    }
    // Field #0 'Epoch'
    {
      fieldsize := 8
      if t.Epoch, err = fn5(t.Epoch, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #1 'Root'
    {
      fieldsize := 32
      if t.Root, err = fn2(t.Root, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    return t, err
  }
  fn26 := func(t []uint64, buf []byte) ([]uint64, error) { // []uint64
    var err error
    buflen := len(buf)
    itemsize := 8
    itemCount := buflen / itemsize
    if buflen % itemsize != 0 {
      return t, sszutils.ErrUnexpectedEOF
    }
    if len(t) < itemCount {
      t = make([]uint64, itemCount)
    } else {
      t = t[:itemCount]
    }
    for i := 0; i < itemCount; i++ {
      if t[i], err = fn1(t[i], buf[i*itemsize:(i+1)*itemsize]); err != nil {
        return t, err
      }
    }
    return t, err
  }
  fn27 := func(t []phase0.BLSPubKey, buf []byte) ([]phase0.BLSPubKey, error) { // []phase0.BLSPubKey:512:SYNC_COMMITTEE_SIZE:48
    var err error
    itemsize := 48
    limit := sfn4 / itemsize
    if len(t) < int(limit) {
      t = make([]phase0.BLSPubKey, int(limit))
    } else {
      t = t[:int(limit)]
    }
    if len(buf) > int(limit) * itemsize {
      return t, sszutils.ErrListTooBig
    }
    for i := 0; i < int(limit); i++ {
      if t[i], err = fn14(t[i], buf[i*itemsize:(i+1)*itemsize]); err != nil {
        return t, err
      }
    }
    return t, err
  }
  fn28 := func(t *altair.SyncCommittee, buf []byte) (*altair.SyncCommittee, error) { // *altair.SyncCommittee
    var err error
    if t == nil {
      t = new(altair.SyncCommittee)
    }
    bufpos := 0
    buflen := len(buf)
    minsize := 48
    if buflen < minsize {
      return t, sszutils.ErrUnexpectedEOF
    }
    // Field #0 'Pubkeys'
    {
      fieldsize := sfn4
      minsize += fieldsize
      if buflen < minsize {
        return t, sszutils.ErrUnexpectedEOF
      }
      if t.Pubkeys, err = fn27(t.Pubkeys, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #1 'AggregatePubkey'
    {
      fieldsize := 48
      if t.AggregatePubkey, err = fn14(t.AggregatePubkey, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    return t, err
  }
  fn29 := func(t phase0.Hash32, buf []byte) (phase0.Hash32, error) { // phase0.Hash32:32
    var err error
    itemsize := 1
    limit := 32
    if len(buf) > int(limit) * itemsize {
      return t, sszutils.ErrListTooBig
    }
    copy(t[:], buf[:])
    return t, err
  }
  fn30 := func(t bellatrix.ExecutionAddress, buf []byte) (bellatrix.ExecutionAddress, error) { // bellatrix.ExecutionAddress:20
    var err error
    itemsize := 1
    limit := 20
    if len(buf) > int(limit) * itemsize {
      return t, sszutils.ErrListTooBig
    }
    copy(t[:], buf[:])
    return t, err
  }
  fn31 := func(t [256]byte, buf []byte) ([256]byte, error) { // [256]byte:256
    var err error
    itemsize := 1
    limit := 256
    if len(buf) > int(limit) * itemsize {
      return t, sszutils.ErrListTooBig
    }
    copy(t[:], buf[:])
    return t, err
  }
  fn32 := func(t [32]byte, buf []byte) ([32]byte, error) { // [32]byte:32
    var err error
    itemsize := 1
    limit := 32
    if len(buf) > int(limit) * itemsize {
      return t, sszutils.ErrListTooBig
    }
    copy(t[:], buf[:])
    return t, err
  }
  fn33 := func(t []byte, buf []byte) ([]byte, error) { // []byte
    var err error
    if len(t) < len(buf) {
      t = make([]byte, len(buf))
    } else {
      t = t[:len(buf)]
    }
    if len(buf) > 0 {
      copy(t[:], buf[:])
    }
    return t, err
  }
  fn34 := func(t *uint256.Int, buf []byte) (*uint256.Int, error) { // *uint256.Int:4
    var err error
    if t == nil {
      t = new(uint256.Int)
    }
    itemsize := 8
    limit := 4
    if len(buf) > int(limit) * itemsize {
      return t, sszutils.ErrListTooBig
    }
    for i := 0; i < int(limit); i++ {
      if t[i], err = fn1(t[i], buf[i*itemsize:(i+1)*itemsize]); err != nil {
        return t, err
      }
    }
    return t, err
  }
  fn35 := func(t *deneb.ExecutionPayloadHeader, buf []byte) (*deneb.ExecutionPayloadHeader, error) { // *deneb.ExecutionPayloadHeader
    var err error
    if t == nil {
      t = new(deneb.ExecutionPayloadHeader)
    }
    bufpos := 0
    buflen := len(buf)
    minsize := 584
    if buflen < minsize {
      return t, sszutils.ErrUnexpectedEOF
    }
    // Field #0 'ParentHash'
    {
      fieldsize := 32
      if t.ParentHash, err = fn29(t.ParentHash, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #1 'FeeRecipient'
    {
      fieldsize := 20
      if t.FeeRecipient, err = fn30(t.FeeRecipient, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #2 'StateRoot'
    {
      fieldsize := 32
      if t.StateRoot, err = fn2(t.StateRoot, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #3 'ReceiptsRoot'
    {
      fieldsize := 32
      if t.ReceiptsRoot, err = fn2(t.ReceiptsRoot, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #4 'LogsBloom'
    {
      fieldsize := 256
      if t.LogsBloom, err = fn31(t.LogsBloom, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #5 'PrevRandao'
    {
      fieldsize := 32
      if t.PrevRandao, err = fn32(t.PrevRandao, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #6 'BlockNumber'
    {
      fieldsize := 8
      if t.BlockNumber, err = fn1(t.BlockNumber, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #7 'GasLimit'
    {
      fieldsize := 8
      if t.GasLimit, err = fn1(t.GasLimit, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #8 'GasUsed'
    {
      fieldsize := 8
      if t.GasUsed, err = fn1(t.GasUsed, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #9 'Timestamp'
    {
      fieldsize := 8
      if t.Timestamp, err = fn1(t.Timestamp, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Offset #10 'ExtraData'
    offset10 := int(sszutils.ReadOffset(buf[bufpos:bufpos+4]))
    bufpos += 4
    // Field #11 'BaseFeePerGas'
    {
      fieldsize := 32
      if t.BaseFeePerGas, err = fn34(t.BaseFeePerGas, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #12 'BlockHash'
    {
      fieldsize := 32
      if t.BlockHash, err = fn29(t.BlockHash, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #13 'TransactionsRoot'
    {
      fieldsize := 32
      if t.TransactionsRoot, err = fn2(t.TransactionsRoot, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #14 'WithdrawalsRoot'
    {
      fieldsize := 32
      if t.WithdrawalsRoot, err = fn2(t.WithdrawalsRoot, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #15 'BlobGasUsed'
    {
      fieldsize := 8
      if t.BlobGasUsed, err = fn1(t.BlobGasUsed, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #16 'ExcessBlobGas'
    {
      fieldsize := 8
      if t.ExcessBlobGas, err = fn1(t.ExcessBlobGas, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Dynamic Field #10 'ExtraData'
    if offset10 < bufpos  {
      return t, sszutils.ErrOffset
    }
    {
      fieldSlice := buf[offset10:]
      if t.ExtraData, err = fn33(t.ExtraData, fieldSlice); err != nil {
        return t, err
      }
      bufpos += len(fieldSlice)
    }
    return t, err
  }
  fn36 := func(_ capella.WithdrawalIndex, buf []byte) (capella.WithdrawalIndex, error) { // capella.WithdrawalIndex
    var err error
    var t capella.WithdrawalIndex
    t = (capella.WithdrawalIndex)(sszutils.UnmarshallUint64(buf))
    return t, err
  }
  fn37 := func(t *capella.HistoricalSummary, buf []byte) (*capella.HistoricalSummary, error) { // *capella.HistoricalSummary
    var err error
    if t == nil {
      t = new(capella.HistoricalSummary)
    }
    bufpos := 0
    buflen := len(buf)
    minsize := 64
    if buflen < minsize {
      return t, sszutils.ErrUnexpectedEOF
    }
    // Field #0 'BlockSummaryRoot'
    {
      fieldsize := 32
      if t.BlockSummaryRoot, err = fn2(t.BlockSummaryRoot, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #1 'StateSummaryRoot'
    {
      fieldsize := 32
      if t.StateSummaryRoot, err = fn2(t.StateSummaryRoot, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    return t, err
  }
  fn38 := func(t []*capella.HistoricalSummary, buf []byte) ([]*capella.HistoricalSummary, error) { // []*capella.HistoricalSummary
    var err error
    buflen := len(buf)
    itemsize := 64
    itemCount := buflen / itemsize
    if buflen % itemsize != 0 {
      return t, sszutils.ErrUnexpectedEOF
    }
    if len(t) < itemCount {
      t = make([]*capella.HistoricalSummary, itemCount)
    } else {
      t = t[:itemCount]
    }
    for i := 0; i < itemCount; i++ {
      if t[i], err = fn37(t[i], buf[i*itemsize:(i+1)*itemsize]); err != nil {
        return t, err
      }
    }
    return t, err
  }
  fn39 := func(t *TestBeaconState, buf []byte) (*TestBeaconState, error) { // *TestBeaconState
    var err error
    if t == nil {
      t = new(TestBeaconState)
    }
    bufpos := 0
    buflen := len(buf)
    minsize := 429
    if buflen < minsize {
      return t, sszutils.ErrUnexpectedEOF
    }
    // Field #0 'GenesisTime'
    {
      fieldsize := 8
      if t.GenesisTime, err = fn1(t.GenesisTime, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #1 'GenesisValidatorsRoot'
    {
      fieldsize := 32
      if t.GenesisValidatorsRoot, err = fn2(t.GenesisValidatorsRoot, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #2 'Slot'
    {
      fieldsize := 8
      if t.Slot, err = fn3(t.Slot, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #3 'Fork'
    {
      fieldsize := 16
      if t.Fork, err = fn6(t.Fork, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #4 'LatestBlockHeader'
    {
      fieldsize := 112
      if t.LatestBlockHeader, err = fn8(t.LatestBlockHeader, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #5 'BlockRoots'
    {
      fieldsize := sfn1
      minsize += fieldsize
      if buflen < minsize {
        return t, sszutils.ErrUnexpectedEOF
      }
      if t.BlockRoots, err = fn9(t.BlockRoots, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #6 'StateRoots'
    {
      fieldsize := sfn1
      minsize += fieldsize
      if buflen < minsize {
        return t, sszutils.ErrUnexpectedEOF
      }
      if t.StateRoots, err = fn9(t.StateRoots, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Offset #7 'HistoricalRoots'
    offset7 := int(sszutils.ReadOffset(buf[bufpos:bufpos+4]))
    bufpos += 4
    // Field #8 'ETH1Data'
    {
      fieldsize := 72
      if t.ETH1Data, err = fn12(t.ETH1Data, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Offset #9 'ETH1DataVotes'
    offset9 := int(sszutils.ReadOffset(buf[bufpos:bufpos+4]))
    bufpos += 4
    // Field #10 'ETH1DepositIndex'
    {
      fieldsize := 8
      if t.ETH1DepositIndex, err = fn1(t.ETH1DepositIndex, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Offset #11 'Validators'
    offset11 := int(sszutils.ReadOffset(buf[bufpos:bufpos+4]))
    bufpos += 4
    // Offset #12 'Balances'
    offset12 := int(sszutils.ReadOffset(buf[bufpos:bufpos+4]))
    bufpos += 4
    // Field #13 'RANDAOMixes'
    {
      fieldsize := sfn2
      minsize += fieldsize
      if buflen < minsize {
        return t, sszutils.ErrUnexpectedEOF
      }
      if t.RANDAOMixes, err = fn20(t.RANDAOMixes, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #14 'Slashings'
    {
      fieldsize := sfn3
      minsize += fieldsize
      if buflen < minsize {
        return t, sszutils.ErrUnexpectedEOF
      }
      if t.Slashings, err = fn21(t.Slashings, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Offset #15 'PreviousEpochParticipation'
    offset15 := int(sszutils.ReadOffset(buf[bufpos:bufpos+4]))
    bufpos += 4
    // Offset #16 'CurrentEpochParticipation'
    offset16 := int(sszutils.ReadOffset(buf[bufpos:bufpos+4]))
    bufpos += 4
    // Field #17 'JustificationBits'
    {
      fieldsize := 1
      if t.JustificationBits, err = fn24(t.JustificationBits, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #18 'PreviousJustifiedCheckpoint'
    {
      fieldsize := 40
      if t.PreviousJustifiedCheckpoint, err = fn25(t.PreviousJustifiedCheckpoint, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #19 'CurrentJustifiedCheckpoint'
    {
      fieldsize := 40
      if t.CurrentJustifiedCheckpoint, err = fn25(t.CurrentJustifiedCheckpoint, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #20 'FinalizedCheckpoint'
    {
      fieldsize := 40
      if t.FinalizedCheckpoint, err = fn25(t.FinalizedCheckpoint, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Offset #21 'InactivityScores'
    offset21 := int(sszutils.ReadOffset(buf[bufpos:bufpos+4]))
    bufpos += 4
    // Field #22 'CurrentSyncCommittee'
    {
      fieldsize := sfn5
      minsize += fieldsize
      if buflen < minsize {
        return t, sszutils.ErrUnexpectedEOF
      }
      if t.CurrentSyncCommittee, err = fn28(t.CurrentSyncCommittee, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #23 'NextSyncCommittee'
    {
      fieldsize := sfn5
      minsize += fieldsize
      if buflen < minsize {
        return t, sszutils.ErrUnexpectedEOF
      }
      if t.NextSyncCommittee, err = fn28(t.NextSyncCommittee, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Offset #24 'LatestExecutionPayloadHeader'
    offset24 := int(sszutils.ReadOffset(buf[bufpos:bufpos+4]))
    bufpos += 4
    // Field #25 'NextWithdrawalIndex'
    {
      fieldsize := 8
      if t.NextWithdrawalIndex, err = fn36(t.NextWithdrawalIndex, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Field #26 'NextWithdrawalValidatorIndex'
    {
      fieldsize := 8
      if t.NextWithdrawalValidatorIndex, err = fn7(t.NextWithdrawalValidatorIndex, buf[bufpos:bufpos+fieldsize]); err != nil {
        return t, err
      }
      bufpos += fieldsize
    }
    // Offset #27 'HistoricalSummaries'
    offset27 := int(sszutils.ReadOffset(buf[bufpos:bufpos+4]))
    bufpos += 4
    // Dynamic Field #7 'HistoricalRoots'
    if offset7 < bufpos || offset9 > buflen || offset9 < offset7 {
      return t, sszutils.ErrOffset
    }
    {
      fieldSlice := buf[offset7:offset9]
      if t.HistoricalRoots, err = fn10(t.HistoricalRoots, fieldSlice); err != nil {
        return t, err
      }
      bufpos += len(fieldSlice)
    }
    // Dynamic Field #9 'ETH1DataVotes'
    if offset9 < bufpos || offset11 > buflen || offset11 < offset9 {
      return t, sszutils.ErrOffset
    }
    {
      fieldSlice := buf[offset9:offset11]
      if t.ETH1DataVotes, err = fn13(t.ETH1DataVotes, fieldSlice); err != nil {
        return t, err
      }
      bufpos += len(fieldSlice)
    }
    // Dynamic Field #11 'Validators'
    if offset11 < bufpos || offset12 > buflen || offset12 < offset11 {
      return t, sszutils.ErrOffset
    }
    {
      fieldSlice := buf[offset11:offset12]
      if t.Validators, err = fn18(t.Validators, fieldSlice); err != nil {
        return t, err
      }
      bufpos += len(fieldSlice)
    }
    // Dynamic Field #12 'Balances'
    if offset12 < bufpos || offset15 > buflen || offset15 < offset12 {
      return t, sszutils.ErrOffset
    }
    {
      fieldSlice := buf[offset12:offset15]
      if t.Balances, err = fn19(t.Balances, fieldSlice); err != nil {
        return t, err
      }
      bufpos += len(fieldSlice)
    }
    // Dynamic Field #15 'PreviousEpochParticipation'
    if offset15 < bufpos || offset16 > buflen || offset16 < offset15 {
      return t, sszutils.ErrOffset
    }
    {
      fieldSlice := buf[offset15:offset16]
      if t.PreviousEpochParticipation, err = fn23(t.PreviousEpochParticipation, fieldSlice); err != nil {
        return t, err
      }
      bufpos += len(fieldSlice)
    }
    // Dynamic Field #16 'CurrentEpochParticipation'
    if offset16 < bufpos || offset21 > buflen || offset21 < offset16 {
      return t, sszutils.ErrOffset
    }
    {
      fieldSlice := buf[offset16:offset21]
      if t.CurrentEpochParticipation, err = fn23(t.CurrentEpochParticipation, fieldSlice); err != nil {
        return t, err
      }
      bufpos += len(fieldSlice)
    }
    // Dynamic Field #21 'InactivityScores'
    if offset21 < bufpos || offset24 > buflen || offset24 < offset21 {
      return t, sszutils.ErrOffset
    }
    {
      fieldSlice := buf[offset21:offset24]
      if t.InactivityScores, err = fn26(t.InactivityScores, fieldSlice); err != nil {
        return t, err
      }
      bufpos += len(fieldSlice)
    }
    // Dynamic Field #24 'LatestExecutionPayloadHeader'
    if offset24 < bufpos || offset27 > buflen || offset27 < offset24 {
      return t, sszutils.ErrOffset
    }
    {
      fieldSlice := buf[offset24:offset27]
      if t.LatestExecutionPayloadHeader, err = fn35(t.LatestExecutionPayloadHeader, fieldSlice); err != nil {
        return t, err
      }
      bufpos += len(fieldSlice)
    }
    // Dynamic Field #27 'HistoricalSummaries'
    if offset27 < bufpos  {
      return t, sszutils.ErrOffset
    }
    {
      fieldSlice := buf[offset27:]
      if t.HistoricalSummaries, err = fn38(t.HistoricalSummaries, fieldSlice); err != nil {
        return t, err
      }
      bufpos += len(fieldSlice)
    }
    return t, err
  }
  _, err = fn39(t, buf)
  return err
}
func (t *TestBeaconState) UnmarshalSSZ(buf []byte) (err error) {
  return t.UnmarshalSSZDyn(dynssz.GetGlobalDynSsz(), buf)
}


