// Code generated by dynamic-ssz. DO NOT EDIT.
package main

import (
	"github.com/attestantio/go-eth2-client/spec/phase0"
	dynssz "github.com/pk910/dynamic-ssz"
	"github.com/pk910/dynamic-ssz/sszutils"
)
var _ = sszutils.ErrListTooBig


func (t *Test1) MarshalSSZDyn(_ *dynssz.DynSsz, buf []byte) (dst []byte, err error) {
  return t.MarshalSSZTo(buf)
}
func (t *Test1) MarshalSSZTo(buf []byte) (dst []byte, err error) {
  dst = buf
  fn1 := func(t phase0.ValidatorIndex) (err error) { // phase0.ValidatorIndex
    dst = sszutils.MarshalUint64(dst, uint64(t))
    return err
  }
  fn2 := func(t phase0.Epoch) (err error) { // phase0.Epoch
    dst = sszutils.MarshalUint64(dst, uint64(t))
    return err
  }
  fn3 := func(t *dynssz.CompatibleUnion[struct { Deneb phase0.ValidatorIndex; Electra phase0.Epoch }]) (err error) { // *dynssz.CompatibleUnion[struct { Deneb phase0.ValidatorIndex; Electra phase0.Epoch }]
    dst = sszutils.MarshalUint8(dst, uint8(t.Variant))
    switch t.Variant {
    case 0:
      v, ok := t.Data.(phase0.ValidatorIndex)
      if !ok {
        return sszutils.ErrInvalidUnionVariant
      }
      if err = fn1(v); err != nil {
        return err
      }
    case 1:
      v, ok := t.Data.(phase0.Epoch)
      if !ok {
        return sszutils.ErrInvalidUnionVariant
      }
      if err = fn2(v); err != nil {
        return err
      }
    default:
      return sszutils.ErrInvalidUnionVariant
    }
    return err
  }
  fn4 := func(t *Test1) (err error) { // *Test1
    dstlen := len(dst)
    // Offset #0 'TestUnion'
    offset0 := len(dst)
    dst = sszutils.MarshalOffset(dst, 0)
    // Dynamic Field #0 'TestUnion'
    sszutils.UpdateOffset(dst[offset0:offset0+4], len(dst)-dstlen)
    if err = fn3(t.TestUnion); err != nil {
      return err
    }
    return err
  }
  err = fn4(t)
  return dst, err
}
func (t *Test1) MarshalSSZ() ([]byte, error) {
  return dynssz.GetGlobalDynSsz().MarshalSSZ(t)
}


func (t *Test1) SizeSSZDyn(_ *dynssz.DynSsz) (size int) {
  return t.SizeSSZ()
}
func (t *Test1) SizeSSZ() (size int) {
  sfn1 := func(t phase0.ValidatorIndex) (size int) { // phase0.ValidatorIndex
    size = 8
    return size
  }
  sfn2 := func(t phase0.Epoch) (size int) { // phase0.Epoch
    size = 8
    return size
  }
  sfn3 := func(t *dynssz.CompatibleUnion[struct { Deneb phase0.ValidatorIndex; Electra phase0.Epoch }]) (size int) { // *dynssz.CompatibleUnion[struct { Deneb phase0.ValidatorIndex; Electra phase0.Epoch }]
    size = 1
    switch t.Variant {
    case 0:
      if v, ok := t.Data.(phase0.ValidatorIndex); ok {
        size += sfn1(v)
      }
    case 1:
      if v, ok := t.Data.(phase0.Epoch); ok {
        size += sfn2(v)
      }
    }
    return size
  }
  sfn4 := func(t *Test1) (size int) { // *Test1
    size = 0
    size += 4 + sfn3(t.TestUnion)
    return size
  }
  return sfn4(t)
}


func (t *Test1) UnmarshalSSZDyn(_ *dynssz.DynSsz, buf []byte) (err error) {
  return t.UnmarshalSSZ(buf)
}
func (t *Test1) UnmarshalSSZ(buf []byte) (err error) {
  fn1 := func(_ phase0.ValidatorIndex, buf []byte) (phase0.ValidatorIndex, error) { // phase0.ValidatorIndex
    var err error
    var t phase0.ValidatorIndex
    t = (phase0.ValidatorIndex)(sszutils.UnmarshallUint64(buf))
    return t, err
  }
  fn2 := func(_ phase0.Epoch, buf []byte) (phase0.Epoch, error) { // phase0.Epoch
    var err error
    var t phase0.Epoch
    t = (phase0.Epoch)(sszutils.UnmarshallUint64(buf))
    return t, err
  }
  fn3 := func(t *dynssz.CompatibleUnion[struct { Deneb phase0.ValidatorIndex; Electra phase0.Epoch }], buf []byte) (*dynssz.CompatibleUnion[struct { Deneb phase0.ValidatorIndex; Electra phase0.Epoch }], error) { // *dynssz.CompatibleUnion[struct { Deneb phase0.ValidatorIndex; Electra phase0.Epoch }]
    var err error
    if t == nil {
      t = new(dynssz.CompatibleUnion[struct { Deneb phase0.ValidatorIndex; Electra phase0.Epoch }])
    }
    if len(buf) < 1 {
      return t, sszutils.ErrUnexpectedEOF
    }
    t.Variant = uint8(buf[0])
    switch t.Variant {
    case 0:
      v, _ := t.Data.(phase0.ValidatorIndex)
      t.Data, err = fn1(v, buf[1:])
    case 1:
      v, _ := t.Data.(phase0.Epoch)
      t.Data, err = fn2(v, buf[1:])
    default:
      return t, sszutils.ErrInvalidUnionVariant
    }
    return t, err
  }
  fn4 := func(t *Test1, buf []byte) (*Test1, error) { // *Test1
    var err error
    if t == nil {
      t = new(Test1)
    }
    bufpos := 0
    buflen := len(buf)
    minsize := 4
    if buflen < minsize {
      return t, sszutils.ErrUnexpectedEOF
    }
    // Offset #0 'TestUnion'
    offset0 := int(sszutils.ReadOffset(buf[bufpos:bufpos+4]))
    bufpos += 4
    // Dynamic Field #0 'TestUnion'
    if offset0 < bufpos  {
      return t, sszutils.ErrOffset
    }
    {
      fieldSlice := buf[offset0:]
      if t.TestUnion, err = fn3(t.TestUnion, fieldSlice); err != nil {
        return t, err
      }
      bufpos += len(fieldSlice)
    }
    return t, err
  }
  _, err = fn4(t, buf)
  return err
}


