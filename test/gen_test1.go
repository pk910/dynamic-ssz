// Code generated by dynamic-ssz. DO NOT EDIT.
package main

import (
	"github.com/attestantio/go-eth2-client/spec/phase0"
	dynssz "github.com/pk910/dynamic-ssz"
	"github.com/pk910/dynamic-ssz/sszutils"
)
var _ = sszutils.ErrListTooBig


func (t *Test1) MarshalSSZDyn(_ *dynssz.DynSsz, buf []byte) (dst []byte, err error) {
  return t.MarshalSSZTo(buf)
}
func (t *Test1) MarshalSSZTo(buf []byte) (dst []byte, err error) {
  dst = buf
  fn1 := func(t *dynssz.CompatibleUnion[struct { Deneb phase0.ValidatorIndex; Electra phase0.Epoch }]) (err error) { // *dynssz.CompatibleUnion[struct { Deneb github.com/attestantio/go-eth2-client/spec/phase0.ValidatorIndex; Electra github.com/attestantio/go-eth2-client/spec/phase0.Epoch }]
    dst = sszutils.MarshalUint8(dst, uint8(t.Variant))
    switch t.Variant {
    case 0:
      v, ok := t.Data.(phase0.ValidatorIndex)
      if !ok {
        return sszutils.ErrInvalidUnionVariant
      }
      dst = sszutils.MarshalUint64(dst, uint64(v))
    case 1:
      v, ok := t.Data.(phase0.Epoch)
      if !ok {
        return sszutils.ErrInvalidUnionVariant
      }
      dst = sszutils.MarshalUint64(dst, uint64(v))
    default:
      return sszutils.ErrInvalidUnionVariant
    }
    return err
  }
  fn2 := func(t *Test1) (err error) { // *main.Test1
    dstlen := len(dst)
    // Offset #0 'TestUnion'
    offset0 := len(dst)
    dst = sszutils.MarshalOffset(dst, 0)
    // Dynamic Field #0 'TestUnion'
    sszutils.UpdateOffset(dst[offset0:offset0+4], len(dst)-dstlen)
    if err = fn1(t.TestUnion); err != nil {
      return err
    }
    return err
  }
  err = fn2(t)
  return dst, err
}
func (t *Test1) MarshalSSZ() ([]byte, error) {
  return dynssz.GetGlobalDynSsz().MarshalSSZ(t)
}

func (t *Test1) SizeSSZDyn(_ *dynssz.DynSsz) (size int) {
  return t.SizeSSZ()
}
func (t *Test1) SizeSSZ() (size int) {
  sfn1 := func(t phase0.ValidatorIndex) (size int) { // phase0.ValidatorIndex
    size = 8
    return size
  }
  sfn2 := func(t phase0.Epoch) (size int) { // phase0.Epoch
    size = 8
    return size
  }
  sfn3 := func(t *dynssz.CompatibleUnion[struct { Deneb phase0.ValidatorIndex; Electra phase0.Epoch }]) (size int) { // *dynssz.CompatibleUnion[struct { Deneb phase0.ValidatorIndex; Electra phase0.Epoch }]
    size = 1
    switch t.Variant {
    case 0:
      if v, ok := t.Data.(phase0.ValidatorIndex); ok {
        size += sfn1(v)
      }
    case 1:
      if v, ok := t.Data.(phase0.Epoch); ok {
        size += sfn2(v)
      }
    }
    return size
  }
  sfn4 := func(t *Test1) (size int) { // *Test1
    size = 0
    size += 4 + sfn3(t.TestUnion)
    return size
  }
  return sfn4(t)
}

func (t *Test1) UnmarshalSSZDyn(_ *dynssz.DynSsz, buf []byte) (err error) {
  return t.UnmarshalSSZ(buf)
}
func (t *Test1) UnmarshalSSZ(buf []byte) (err error) {
  fn1 := func(t *dynssz.CompatibleUnion[struct { Deneb phase0.ValidatorIndex; Electra phase0.Epoch }], buf []byte) (*dynssz.CompatibleUnion[struct { Deneb phase0.ValidatorIndex; Electra phase0.Epoch }], error) { // *dynssz.CompatibleUnion[struct { Deneb phase0.ValidatorIndex; Electra phase0.Epoch }]
    var err error
    if t == nil {
      t = new(dynssz.CompatibleUnion[struct { Deneb phase0.ValidatorIndex; Electra phase0.Epoch }])
    }
    if len(buf) < 1 {
      return t, sszutils.ErrUnexpectedEOF
    }
    t.Variant = uint8(buf[0])
    switch t.Variant {
    case 0:
      v, _ := t.Data.(phase0.ValidatorIndex)
      v = (phase0.ValidatorIndex)(sszutils.UnmarshallUint64(buf[1:]))
      t.Data = v
    case 1:
      v, _ := t.Data.(phase0.Epoch)
      v = (phase0.Epoch)(sszutils.UnmarshallUint64(buf[1:]))
      t.Data = v
    default:
      return t, sszutils.ErrInvalidUnionVariant
    }
    return t, err
  }
  fn2 := func(t *Test1, buf []byte) (*Test1, error) { // *Test1
    var err error
    if t == nil {
      t = new(Test1)
    }
    bufpos := 4
    buflen := len(buf)
    if buflen < 4 {
      return t, sszutils.ErrUnexpectedEOF
    }
    // Read offset #0 'TestUnion'
    offset0 := int(sszutils.ReadOffset(buf[0:4]))
    // Dynamic Field #0 'TestUnion'
    if offset0 < bufpos  {
      return t, sszutils.ErrOffset
    }
    {
      fieldSlice := buf[offset0:]
      if t.TestUnion, err = fn1(t.TestUnion, fieldSlice); err != nil {
        return t, err
      }
      bufpos += len(fieldSlice)
    }
    return t, err
  }
  _, err = fn2(t, buf)
  return err
}

