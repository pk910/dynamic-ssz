{{ define "unmarshal_main" }}
{{- if and .CreateDynamicFn (not .UsedDynSsz) }}
func (t {{ .TypeName }}) UnmarshalSSZDyn(_ *dynssz.DynSsz, buf []byte) (err error) {
  return t.UnmarshalSSZ(buf)
}
{{- end }}
{{- if .UsedDynSsz }}
func (t {{ .TypeName }}) UnmarshalSSZDyn(ds *dynssz.DynSsz, buf []byte) (err error) {
{{- else }}
func (t {{ .TypeName }}) UnmarshalSSZ(buf []byte) (err error) {
{{- end }}
  {{- range .StaticSizeFunctions }}
  {{ .Name }} := func() (size int) { // {{ .Key }}
    {{- indent .Code 4 }}
    return size
  }()
  {{- end }}
  {{- range .UnmarshalFunctions }}
  {{ .Name }} := func({{ if .UsedValue }}t{{ else }}_{{ end }} {{ .TypeName }}, buf []byte) ({{ .TypeName }}, error) { // {{ .Key }}
    var err error
    {{- if not .UsedValue }}
    var t {{ .TypeName }}
    {{- end }}
    {{- if .IsPointer }}
    if t == nil {
      t = new({{ .InnerType }})
    }
    {{- end }}
    {{- indent .Code 4 }}
    return t, err
  }
  {{- end }}
  _, err = {{ .RootFnName }}(t, buf)
  return err
}
{{- if and .CreateLegacyFn .UsedDynSsz }}
func (t {{ .TypeName }}) UnmarshalSSZ(buf []byte) (err error) {
  return t.UnmarshalSSZDyn(dynssz.GetGlobalDynSsz(), buf)
}
{{- end }}
{{ end }}

{{ define "unmarshal_fastssz" }}
err = t.UnmarshalSSZ(buf)
{{- end }}

{{ define "unmarshal_dynamic" }}
err = t.UnmarshalSSZDyn(ds, buf)
{{- end }}

{{ define "unmarshal_size_fastssz" }}
t := new({{ .TypeName }})
size = t.SizeSSZ()
{{- end }}

{{ define "unmarshal_wrapper" }}
t.Data, err = {{ .UnmarshalFn }}(t.Data, buf)
{{- end }}

{{ define "unmarshal_size_wrapper" }}
size = {{ .SizeFn }}
{{- end }}

{{ define "unmarshal_bool" }}
t = ({{ .TypeName }})(sszutils.UnmarshalBool(buf))
{{- end }}

{{ define "unmarshal_uint8" }}
t = ({{ .TypeName }})(sszutils.UnmarshallUint8(buf))
{{- end }}

{{ define "unmarshal_uint16" }}
t = ({{ .TypeName }})(sszutils.UnmarshallUint16(buf))
{{- end }}

{{ define "unmarshal_uint32" }}
t = ({{ .TypeName }})(sszutils.UnmarshallUint32(buf))
{{- end }}

{{ define "unmarshal_uint64" }}
t = ({{ .TypeName }})(sszutils.UnmarshallUint64(buf))
{{- end }}

{{ define "unmarshal_struct" }}
{{- if .HasDynamicSizes }}
bufpos := 0
buflen := len(buf)
minsize := {{ .Size }}
if buflen < minsize {
  return t, sszutils.ErrUnexpectedEOF
}
{{- else }}
{{- if .HasDynamicFields }}
bufpos := {{ .Size }}
{{- end }}
buflen := len(buf)
if buflen < {{ .Size }} {
  return t, sszutils.ErrUnexpectedEOF
}
{{- range .Fields }}
{{- if .IsDynamic }}
// Read offset #{{ .Index }} '{{ .Name }}'
offset{{ .Index }} := int(sszutils.ReadOffset(buf[{{ index $.StaticOffsets .Index }}:{{ add (index $.StaticOffsets .Index) 4 }}]))
{{- end }}
{{- end }}
{{- end }}
{{- if .HasDynamicSizes }}
{{- range .Fields }}
{{- if .IsDynamic }}
// Offset #{{ .Index }} '{{ .Name }}'
offset{{ .Index }} := int(sszutils.ReadOffset(buf[bufpos:bufpos+4]))
bufpos += 4
{{- else }}
// Field #{{ .Index }} '{{ .Name }}'
{
  {{- if .SizeFn }}
  fieldsize := {{ .SizeFn.Name }}
  minsize += fieldsize
  if buflen < minsize {
    return t, sszutils.ErrUnexpectedEOF
  }
  {{- else }}
  fieldsize := {{ .Size }}
  {{- end }}
  {{- if .InlineUnmarshalCode }}
  {{ indent .InlineUnmarshalCode 2 }}
  {{- else }}
  if t.{{ .Name }}, err = {{ .UnmarshalFn }}(t.{{ .Name }}, buf[bufpos:bufpos+fieldsize]); err != nil {
    return t, err
  }
  {{- end }}
  bufpos += fieldsize
}
{{- end }}
{{- end }}
{{- else }}
{{- range .Fields }}
{{- if not .IsDynamic }}
// Field #{{ .Index }} '{{ .Name }}'
{{- if .InlineUnmarshalCode }}
{{ .InlineUnmarshalCode }}
{{- else }}
if t.{{ .Name }}, err = {{ .UnmarshalFn }}(t.{{ .Name }}, buf[{{ index $.StaticOffsets .Index }}:{{ add (index $.StaticOffsets .Index) .Size }}]); err != nil {
  return t, err
}
{{- end }}
{{- end }}
{{- end }}
{{- end }}
{{- range .Fields }}
{{- if .IsDynamic }}
// Dynamic Field #{{ .Index }} '{{ .Name }}'
if offset{{ .Index }} < bufpos {{ if gt .NextDynamic 0 }}|| offset{{ .NextDynamic }} > buflen || offset{{ .NextDynamic }} < offset{{ .Index }}{{ end }} {
  return t, sszutils.ErrOffset
}
{
  fieldSlice := buf[offset{{ .Index }}:{{ if gt .NextDynamic 0 }}offset{{ .NextDynamic }}{{ end }}]
  {{- if .InlineUnmarshalCode }}
  {{ indent .InlineUnmarshalCode 2 }}
  {{- else }}
  if t.{{ .Name }}, err = {{ .UnmarshalFn }}(t.{{ .Name }}, fieldSlice); err != nil {
    return t, err
  }
  {{- end }}
  bufpos += len(fieldSlice)
}
{{- end }}
{{- end }}
{{- end }}

{{ define "unmarshal_size_struct" }}
size = {{ .Size }}
{{- range .Fields }}
{{- if .SizeFn }}
size += {{ .SizeFn }}
{{- end }}
{{- end }}
{{- end }}

{{ define "unmarshal_vector" }}
{{- if .ItemSizeFn }}
itemsize := {{ .ItemSizeFn.Name }}
{{- else }}
itemsize := {{ .ItemSize }}
{{- end }}
{{- if .SizeFn }}
limit := {{ .SizeFn.Name }} / itemsize
{{- else }}
limit := {{ .Length }}
{{- end }}
{{- if and (not .IsArray) (not .IsString) }}
if len(t) < int(limit) {
  t = make({{ .TypeName }}, int(limit))
} else {
  t = t[:int(limit)]
}
{{- end }}
if len(buf) > int(limit) * itemsize {
  return t, sszutils.ErrListTooBig
}
{{- if .IsString }}
t = string(buf)
{{- else if .IsByteArray }}
copy(t[:], buf[:])
{{- else }}
for i := 0; i < int(limit); i++ {
  {{- if .InlineItemUnmarshalCode }}
  {{ indent .InlineItemUnmarshalCode 2 }}
  {{- else }}
  if t[i], err = {{ .UnmarshalFn }}(t[i], buf[i*itemsize:(i+1)*itemsize]); err != nil {
    return t, err
  }
  {{- end }}
}
{{- end }}
{{- end }}

{{ define "unmarshal_size_vector" }}
{{- if not (eq .SizeExpr "") }}
hasLimit, limit, _ := ds.ResolveSpecValue("{{ .SizeExpr }}")
if !hasLimit {
  limit = {{ .Length }}
}
{{- else }}
limit := {{ .Length }}
{{- end }}
{{- if .SizeFn }}
if len(t) > 0 {
  size += int(limit) * {{ .SizeFn }}
} else {
  size += int(limit) * {{ .SizeFn }}
}
{{- else }}
size += int(limit) * {{ .ItemSize }}
{{- end }}
{{- end }}

{{ define "unmarshal_dynamic_vector" }}
{{- if not (eq .SizeExpr "") }}
hasLimit, limit, err := ds.ResolveSpecValue("{{ .SizeExpr }}")
if err != nil {
  return t, err
}
if !hasLimit {
  limit = {{ .Length }}
}
{{- else }}
limit := {{ .Length }}
{{- end }}
{{- if not .IsArray }}
if len(t) < int(limit) {
  t = make({{ .TypeName }}, int(limit))
} else {
  t = t[:int(limit)]
}
{{- end }}
buflen := len(buf)
if buflen < 4 {
  return t, sszutils.ErrUnexpectedEOF
}
offset := sszutils.ReadOffset(buf[0:4])
itemCount := int(offset / 4)
if itemCount > int(limit) {
  return t, sszutils.ErrListTooBig
}
if buflen < int(limit) * 4 {
  return t, sszutils.ErrUnexpectedEOF
}
var endOffset int
for i := 0; i < itemCount; i++ {
  if i < itemCount-1 {
    endOffset = int(sszutils.ReadOffset(buf[(i+1)*4:(i+2)*4]))
  } else {
    endOffset = buflen
  }
  if endOffset < offset || endOffset > buflen {
    return t, sszutils.ErrOffset
  }
  if t[i], err = {{ .UnmarshalFn }}(t[i], buf[offset:endOffset]); err != nil {
    return t, err
  }
  offset = endOffset
}
{{- end }}

{{ define "unmarshal_list" }}
{{- if .IsString }}
t = string(buf)
{{- else if .IsByteArray }}
if len(t) < len(buf) {
  t = make({{ .TypeName }}, len(buf))
} else {
  t = t[:len(buf)]
}
if len(buf) > 0 {
  copy(t[:], buf[:])
}
{{- else }}
buflen := len(buf)
{{- if .SizeFn }}
itemsize := {{ .SizeFn.Name }}
{{- else }}
itemsize := {{ .ItemSize }}
{{- end }}
itemCount := buflen / itemsize
if buflen % itemsize != 0 {
  return t, sszutils.ErrUnexpectedEOF
}
if len(t) < itemCount {
  t = make({{ .TypeName }}, itemCount)
} else {
  t = t[:itemCount]
}
for i := 0; i < itemCount; i++ {
  {{- if .InlineItemUnmarshalCode }}
  {{ indent .InlineItemUnmarshalCode 2 }}
  {{- else }}
  if t[i], err = {{ .UnmarshalFn }}(t[i], buf[i*itemsize:(i+1)*itemsize]); err != nil {
    return t, err
  }
  {{- end }}
}
{{- end }}
{{- end }}

{{ define "unmarshal_dynamic_list" }}
buflen := len(buf)
if buflen == 0 {
  return t, nil
}
if buflen < 4 {
  return t, sszutils.ErrUnexpectedEOF
}
offset := int(sszutils.ReadOffset(buf[0:4]))
itemCount := offset / 4
if buflen < itemCount * 4 {
  return t, sszutils.ErrUnexpectedEOF
}
if len(t) < itemCount {
  t = make({{ .TypeName }}, itemCount)
} else {
  t = t[:itemCount]
}
var endOffset int
for i := 0; i < itemCount; i++ {
  if i < itemCount-1 {
    endOffset = int(sszutils.ReadOffset(buf[(i+1)*4:(i+2)*4]))
  } else {
    endOffset = buflen
  }
  if endOffset < offset || endOffset > buflen {
    return t, sszutils.ErrOffset
  }
  {{- if .InlineItemUnmarshalCode }}
  {{ indent .InlineItemUnmarshalCode 2 }}
  {{- else }}
  if t[i], err = {{ .UnmarshalFn }}(t[i], buf[offset:endOffset]); err != nil {
    return t, err
  }
  {{- end }}
  offset = endOffset
}
{{- end }}

{{ define "unmarshal_compatible_union" }}
if len(buf) < 1 {
  return t, sszutils.ErrUnexpectedEOF
}
t.Variant = uint8(buf[0])
switch t.Variant {
{{- range .VariantFns }}
case {{ .Index }}:
  v, _ := t.Data.({{ .TypeName }})
  {{- if .InlineUnmarshalCode }}
  {{ indent .InlineUnmarshalCode 2 }}
  t.Data = v
  {{- else }}
  t.Data, err = {{ .UnmarshalFn }}(v, buf[1:])
  {{- end }}
{{- end }}
default:
  return t, sszutils.ErrInvalidUnionVariant
}
{{- end }}